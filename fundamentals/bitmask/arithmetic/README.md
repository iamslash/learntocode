# Abstract

# Idea

**Summation**

1. 덧셈의 원리 
   1. 두 수 `a`와 `b`의 덧셈을 할 때, 우리는 각 자리의 비트를 더하는 과정을 거칩니다.
      1. 비트 합 (Sum): 같은 자리의 비트를 XOR (`^`) 연산으로 계산합니다. XOR은 각 비트가 다를 때 1을 반환합니다. 즉, 올림수를 고려하지 않은 상태에서 두 비트의 합을 구합니다.
      2. 올림수 (Carry): 같은 자리의 비트를 AND (`&`) 연산으로 계산하여 구합니다. AND 연산은 두 비트가 모두 1일 때 1을 반환하므로, 이는 올림수를 나타냅니다. 이 올림수는 다음 자리로 이동하기 위해 왼쪽으로 한 자리(`<< 1`) 이동시킵니다.
2. 반복 과정
   1. `a`와 `b`를 더하기 위해, 먼저 `a`와 `b`의 비트 합(`a ^ b`)을 구해 `a`에 저장하고, 올림수(`a & b << 1`)를 `b`에 저장합니다.
   2. 이 과정을 `b`가 0이 될 때까지 반복합니다.
      1. `b`가 0이 되면 더 이상 올림수가 발생하지 않으므로, `a`는 최종 합계를 가지게 됩니다.
3. 코드 동작 설명
   1. 초기 조건에서 a나 b가 0이면, 다른 값이 그대로 결과가 됩니다.
   2. 반복문에서 a와 b의 비트 합을 a에 저장하고, 올림수를 b에 저장하여, b가 0이 될 때까지 덧셈을 반복합니다.
   3. b가 0이 되면 올림수가 없으므로 a가 최종 합을 가지고 반복문을 종료하며, 그 결과를 반환합니다.
4. 이해하기 쉽게 비유하자면
   1. a와 b는 각각 일종의 상자에 들어있는 수이며, 상자 내의 각 자리가 비트입니다.
   2. XOR은 같은 자리의 비트를 더하여, 올림수를 고려하지 않고 새로운 값을 만듭니다.
   3. AND는 두 비트가 모두 1인 경우 올림수를 만들어내고, 이 올림수는 한 자리 왼쪽으로 이동하여 다음 자리와 더해집니다.
   4. 이 과정을 반복하여 더 이상 올림수가 발생하지 않을 때, a는 최종 합계를 가지게 됩니다.

**Subtraction**

1. 뺄셈의 원리
   1. 두 수 `a`와 `b`의 뺄셈을 할 때, 각 자리의 비트를 빼는 과정을 거칩니다.
      1. 비트 차이 (Difference): 같은 자리의 비트를 XOR (`^`) 연산으로 계산합니다. XOR은 두 비트가 다를 때 1을 반환하여, 빼기 연산에서 두 비트의 차이를 계산하는 역할을 합니다.
      2. 빌림수 (Borrow): 빌림이 발생할 수 있는 비트를 찾기 위해 `~a & b`를 계산합니다. `~a`는 `a`의 각 비트를 반전시키며, `b`와 AND 연산을 통해 빌림수가 필요한 자리를 파악합니다. 이 빌림수는 한 자리 왼쪽으로 이동(`<< 1`)하여 다음 자리에서 처리됩니다.
2. 반복 과정
   1. 먼저 `a`와 `b`의 비트 차이(`a ^ b`)를 구해 `a`에 저장하고, 빌림수(`~a & b << 1`)를 `b`에 저장합니다.
   2. 이 과정을 `b`가 0이 될 때까지 반복합니다.
      1. `b`가 0이 되면 더 이상 빌림이 발생하지 않으므로, `a`는 최종 차이를 가지게 됩니다.
3. 코드 동작 설명
   1. 반복문에서 a와 b의 비트 차이를 a에 저장하고, 빌림수를 b에 저장하여, b가 0이 될 때까지 뺄셈을 반복합니다.
   2. b가 0이 되면 더 이상 빌림이 없으므로 a가 최종 차이를 가지고 반복문을 종료하며, 그 결과를 반환합니다.
4. 이해하기 쉽게 비유하자면
   1. a는 현재 값, b는 빼야 할 값입니다.
   2. XOR은 각 자리에서 빼기를 수행하며, 빌림이 발생할 자리는 AND와 NOT 연산을 통해 파악합니다.
   3. 빌림이 발생하면, 이를 왼쪽으로 한 자리 이동시켜 다음 자리에서 처리합니다.
   4. 이 과정을 반복하여 빌림이 더 이상 필요 없을 때, a는 최종 뺄셈 결과를 가지게 됩니다.

**Negation**

1. 부호 반전의 원리
   1. 2의 보수라는 개념을 이용합니다. 2의 보수는 이진수에서 숫자의 음수를 표현하는 방법으로, 어떤 수의 2의 보수를 구하면 그 수의 음수가 됩니다.
2. 2의 보수 계산
   1. 1의 보수 (One's Complement): `~x`는 x의 모든 비트를 반전시킵니다. 즉, 0은 1로, 1은 0으로 바꿉니다.
   2. 2의 보수 (Two's Complement): `~x + 1`은 x의 2의 보수를 계산하여 x의 음수를 구합니다. 이는 비트를 반전시킨 후 1을 더하는 방식입니다.
3. 코드 동작 설명
   1. `~x`는 `x`의 모든 비트를 반전시킵니다. 예를 들어, `x`가 5라면, 이진수로 `0101`이 되고, 이를 반전하면 `1010`이 됩니다.
   2. 여기에 `+1`을 더하면, 2의 보수를 계산하게 되어 x의 음수 값을 얻게 됩니다. 위의 예에서는 `1010 + 1 = 1011`이 되며, 이는 -5를 의미합니다.
   3. 결과적으로, 이 코드에서 `x`가 5라면, -5를 반환하게 됩니다.
4. 간단한 비유
   1. `~x`는 `x`의 "모양"을 반대로 뒤집는 과정이라고 생각할 수 있습니다.
   2. `+1`을 더하는 것은 "뒤집은 모양"을 실제 음수로 바꾸기 위한 최종 단계입니다.

# Implementation

- [java17](MainApp.java)

# Complexity

```
O(N) O(1)
```
