# Abstract

insertion sort 는 주어진 수열이 어느 정도 정렬되어 있으면
매우 효율적이다. 이미 정렬되어 있다면 시간복잡도는 `O(N)` 이다.

# Problem

수열 `V` 가 주어지면 insertion sort 를
이용하여 정렬하자.

# Idea

`V` 를 인덱스 `i` 를 이용하여 순회하자. 이때 `i` 가 증가할 때 마다
인덱스 `j` 를 `i` 부터 하나씩 감소한다.

`j` 가 감소할 때마다 `A[j]` 와 `A[j-1]` 의 숫자를 비교하여 
정렬 되지 않았으면 `A[j]` 와 `A[j-1]` 를 교체한다. 이미 정렬되어 있다면
인덱스 `j` 의 루프는 중지한다.

이때 두가지 불변식을 만들어 낼 수 있다.
첫번째는 `A[j+1..i]` 는 모두 `A[j]` 보다 크다.
두번째는 `A[0..i]` 는 모두 `A[j]` 를 제외하면 정렬되어 있다.

예를 들어 다음과 같이 `V` 를 삽입정렬해보자.

```
   i              i              i              i
   j              j              j              j
V: 1 5 3 2 4    1 5 3 2 4    1 3 5 2 4    1 3 2 5 4

         i              i
       j                j
V: 1 2 3 5 4    1 2 3 4 5
```

# Implementation

* [c++11](a.cpp)

# Time Complexity

```
O(N^2) O(1)
```
