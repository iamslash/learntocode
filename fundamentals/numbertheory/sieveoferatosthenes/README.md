# Abstract

에라토스테네스의 체에 대해 적는다.

# Problem

숫자 `n` 이 주어지면 `[1..n]` 의 숫자들중 소수들을 구하는 문제이다.

# Idea

`2` 부터 `n` 까지의 모든 숫자를 순회하면서 소수가 아닌 녀석들을
제거한다. 이러한 과정을 `n` 까지 수행하고 나면 남은 수들은 소수가 된다. 이때
제거되는 숫자들은 합성수이다. 임의의 합성수 `m` 을 `p * q` 로 표현해보자.
`p` 는 항상 `sqrt(n)` 보다 작거나 같고 `q` 는 `sqrt(n)` 보다 크거나 같다.
`m` 을 `q x p` 로 표현하는 경우는 고려대상이 아니다. `p * q` 를 통해서 이미 제거되기
때문이다.  따라서 `p` 에 해당하는 `i` 는 `2` 부터 `sqrt(n)` 까지만 살펴보면
된다.

예를 들어서 `n` 이 `100` 일때 `p` 가 `10` 이면 `q` 는 `10` 이다. 또한 `p` 가 `20`인 경우는 `q` 가 `5` 이다. 이때 `20 * 5` 는 `5 * 20` 과 같고 `p` 가 `5` 인 경우는 이미
처리되었기 때문에 `p` 가 `20` 인 경우는 고려대상이 아니다.

`i` 가 정해지면 `i` 의 배수이면서 `n` 보다 작거나 같은 합성수 `j` 를 만들어야
한다. 이때 `j` 는 `i * x` 로 표현할 수 있다. `x` 는 `2` 보다 크거나 같다고
생각할 수 있지만 `i` 가 `2` 보다 크다면 `2` 는 고려대상이 아니다. 만약 `x` 가
`i` 보다 작다면 `x * i` 는 이미 처리되었기 때문이다.

예를 들어서 `i` 가 `10` 일때 `x` 는 `2` 이라고 가정해보자. `j` 는 `10 * 2` 로 표현할
수 있다. 이것은 `2 * 10` 과 같고 `i` 가 `2` 일때 이미 처리 되었기 때문에
고려할 대상이 아니다.

# Implementation

* [c++11](a.cpp)

# Complexity

```
O(sqrt(N)N) O(N)
```