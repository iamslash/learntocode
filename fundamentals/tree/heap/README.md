# Abstract

이진 힙 (binary heap) 에 대해 정리한다. 

# References

* [Binary Heap](https://www.geeksforgeeks.org/binary-heap/)

# Data Structure Heap

힙은 우선순위가 가장 큰 노드를 `O(1)` 의 시간으로 얻어 올 수 있다.
그렇기 때문에 힙은 주로 우선 순위 큐를 구현할 때 사용 한다.
힙은 새 원소를 삽입, 삭제 할 때 마다 균형을 유지하기 때문에 새 원소를
삽입하는 것과 삭제하는 것을 `O(lgN)` 의 시간에 수행 할 수 있다.

힙은 다음과 같은 조건들을 만족 해야 한다.

* 부모 노드의 우선 순위는 자식 노드의 우선 순위보다 크거나 같다. BST 는
  대소관계가 형제끼리도 적용되지만 힙은 그렇지 않다.
* 마지막 레벨을 제외한 모든 레벨은 노드가 꽉 차 있어야 한다.
* 마지막 레벨의 노드는 가장 왼쪽 부터 순서대로 채워져 있어야 한다.

힙은 다음과 같이 배열 하나로 표현 가능하다.

```cpp
vector<int> m_data;
```

이때 특정 노드 `i` 의 왼쪽 자식은 `2i + 1` 오른쪽 자식은 `2i + 2` 로
표현 가능 하다. 또한 부모는 `(i/2)-1` 로 표현 가능 하다.

# Algorithm Push

## Idea

특정 노드를 마지막 노드로 삽입한다. 삽입된 노드는 루트 노드 방향으로 
우선 순위 대소 관계가 성립할 때까지 올라 간다.

다음은 힙에 우선 순위가 10 인 녀석을 삽입하는 예이다.

```

       20          20            20
      /  \  =>    /  \   =>     /  \
     8    9      8    9        10   9 
                /             /
               10            8
```

## Complexity

```
O(lgN) O(1)
```

# Algorithm Pop

## Idea

대략의 과정은 이러하다. 루트 노드를 저장하고 나중에 리턴한다. 마지막
노드 즉 `m_data.back()` 를 루트노드에 옮겨 놓고 리프 노드 방향으로
우선순위를 고려하여 자리바꿈을 한다. 이것을 그림으로 표현하면 다음과
같다.

```

      20    =>      ?    =>     8    =>     10
     /  \          / \         / \         /  \
    9   10        9  10       9   10      9    8
   /             /           
  8             8
```

그렇다면 좀더 구체적으로 정리해 본다.

`int t` 선언하여 `m_data[0]` 을 저장한다. `m_data[0] = m_data.back(),
m_data.pop_back()` 을 수행한다. `int u = 0` 를 선언하여 방문할 노드를
저장한다. 그리고 다음을 무조건 반복한다.

* `int v` 를 선언하여 `u` 를 저장한다. `v` 는 교체해야할 인덱스이다.
* `int l = 2*u + 1`, `int r = 2*u + 2` 를 수행한다.
* `l >= n` 이면 왼쪽 자식이 없다는 의미이다. 반복을
  종료한다.
* `m_data[v] < m_data[l]` 이면 `v = l` 이다.
* `r < n && m_data[v] < m_data[r]` 이면 `v = r` 이다.
* `u == v` 교체될 녀석이 없다는 의미이다. 반복을 종료한다.
* `m_data[u]` 와 `m_data[v]` 를 교체한다.
* `u = v` 를 수행한다.

모든 반복을 마치면 `t` 를 리턴한다.

## Complexity

```
O(lgN) O(1)
```

# Implementation

* [c++11](a.cpp)
