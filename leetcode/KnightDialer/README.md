# Problem

[Knight Dialer](https://leetcode.com/problems/knight-dialer/)

# Idea

```
1 2 3
4 5 6
7 8 9
  0
```

위와 같이 `0-9` 까지의 숫자로 구성된 키패드가 있다.  숫자 `N` 이
주어지면 임의 숫자 부터 출발하여 `N-1` 만큼 다음 숫자를 만들어 낸다.
다음 숫자는 이전 숫자에서 체스의 나이트 처럼 움직여서 만난 숫자이다.
이런 방식으로 만들 수 있는 `N` 자리 숫자의 개수를 구하는 문제이다.

예를 들어, `0` 에서 출발하면 `6, 8` 에 도착할 수 있다. `2` 에서
출발하면 `7, 9` 에 도착할 수 있다. 이런 식으로 각 숫자에서 출발했을 때
만나는 다음 숫자는 다음과 같다.

```
0: {4, 6} 
1: {6, 8} 
2: {7, 9}
3: {4, 8}
4: {3, 9, 0}
5: {}
6: {1, 7, 0}
7: {2, 6}
8: {1, 3}
9: {2, 4}
```

이전에 구했던 것을 이용하여 새로운 것을 구한다.  dynamic programming
이라 할 만 하다.

캐시 `C[][]` 를 선언하여 해결해 보자.

`N` 을 하나씩 감소하면서 거꾸로 생각해 보자.  예를 들어 여차 저차 해서
`N-2` 번째에 `0` 까지 왔다면 다음으로 갈 수 있는 숫자는 `4, 6` 이다.
따라서 `C[N-2][0] = C[N-1][4] + C[N-1][6]` 이다.
여차 저차 해서 `N-3` 번 째에 `1` 까지 왔다면 당므으로 갈 수 있는 숫자는
`6, 8` 이므로 `C[N-3][1] = C[N-2][6] + C[N-2][8]` 이다.

따라서 다음과 같은 식을 만들어 낼 수 있다.

```
C[i][u] = C[i+1][v0] + C[i+1][v1] + ...
```

캐시를 일차원 두개를 이용하면 공간복잡도를 더욱 낮출 수 있다.


# Implmenetation

* [c++11](a.cpp)

# Complexity

```
O(N) O(1)
```
