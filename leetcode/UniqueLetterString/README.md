# Problem

* [Unique Letter String](https://leetcode.com/problems/unique-letter-string/)

# Idea

대문자로 이루어진 문자열 `S` 가 주어진다. 임의의 문자열 `s` 에 대해
유니크한 문자의 개수를 리턴하는 함수를 `U(s)` 로 정의하자.  예를 들어
`U("LETTER") = 2` 이다. `S` 의 부분문자열 `substr(S)` 에 대해 `A =
sum(U(substr(S)))` 을 구하는 문제이다. 만약 `S = ABC` 이면
부분문자열은 `A, B, C, AB, BC, ABC` 이고 `1 + 1 + 1 + 2 + 2 + 3 = 10`
이므로 답은 `10` 이다.

부분문자열은 `S` 의 연속된 부분문자열이다. 예를 들어 `S = LETTER`
일 때 `ET` 는 부분문자열이지만 `LR` 은 부분문자열이 아니다.

전체 부분문자열을 만들어서 답을 산출하는 것은 시간 복잡도가 너무 크다.
유니크한 문자를 기준으로 가지수를 추론해보자. 하나의 문자에 대해 그
문자가 유니크함이 보장되는 영역이 어디서 부터 어디까지인지 알 수
있다면 그 문자에 대해 제작가능한 부분문자열의 개수를 알아낼 수 있다.

예를 들어서 `S = "LETTER"` 를 살펴보자. 

문자 `L` 을 기준으로
`L` 이 유니크함이 보장되는 경우는 `L, LE LET, LETT, LETTE, LETTER`
과 같이 `6` 가지이다.

문자 `E` 를 기준으로 `E` 가 유니크함이 보장되는 경우는 `LE, LET, LETT, E, ET, ETT`
과 같이 `6` 가지이다.

문자 `T` 를 기준으로 `T` 가 유니크함이 보장되는 경우는 `LET, ET, T` 와 같이 `3`
가지이다.

위와 같은 겨우를 통해 몇가지 규칙을 발견할 수 있다. 각 문자의 유니크함이 보장되는 최대 왼쪽 인덱스의 거리와 최대 오른쪽 인덱스거리를 곱하면 제작가능한 부분문자열의 개수를 구할 수
있다.

다음은 인덱스 `l, r, i` 을 이용해서 `S = LELTL` 에서 문자 `L` 의 유니크함이 보장되는 `S` 의 부분문자열의 개수를 구하는 과정이다. seed number 로 `-1` 을 사용했고
`i` 가 순회를 마친 경우는 `i` 대신 `n=S.size()` 를 사용했다. 그 외의 경우는
`r-l*i-r` 을 이용하여 개수를 구했다. 

```
       r                
       l i             l r   i           l   r   i           l   r
S   = -1 L E L T L    -1 L E L T L    -1 L E L T L    -1 L E L T L
cnt =  r-l*i-r = 0     r-l*i-r = 2     r-l*i-r = 4     r-l*n-r = 2
```

# Implementation

* [c++11](a.cpp)

# Complexity

```
O(N) O(1)
```
