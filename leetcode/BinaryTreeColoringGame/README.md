# Problem

[Binary Tree Coloring Game](https://leetcode.com/problems/binary-tree-coloring-game/)

# Idea

트리의 루트노드 `u`, 노드의 개수 `n`, 값 `x` 가 주어진다.  두명의
플레이어 `P1, P2` 가 색칠하는 게임을 한다. `P1` 은 빨간색으로 `P2` 는
파란색으로 칠한다. `P1` 이 먼저 시작한다. 플레이어는 특정 노드를
선택하면 연결된 왼쪽 자식, 오른쪽 자식, 부모를 더이상 칠할 수 없을 때
까지 칠할 수 있다. 가장 많은 노드를 칠한 플레이어가 이긴다. `P2` 가
반드시 이길 수 있는지 검증하는 문제이다.

예를 들어 다음과 같은 경우를 살펴보자. `3` 의 값을 갖는 노드 `u` 를
`P1` 이 빨간색으로 칠한다고 해보자. 

```
                    1
                 /     \ 
                2       3
              /   \   /   \
             4     5 6     7
            / \   / \
           8   9 10  11
```

다음은 `P1` 의 선택에 따라 가능한 `P2` 의 선택이다.

| id | `P1` | `P2` |
|----|------|------|
| 0  | up `1,2,4,5,8,9,10,11` | left `6` or right `7` |
| 1  | left `6` | up `1,2,4,5,8,9,10,11` or right `7` |
| 2  | right `7` | left `6` or up `1,2,4,5,8,9,10,11` |

`P2` 가 이기기 위해서는 `1, 2` 번 방법이 가능하다. 따라서 `true`
를 리턴한다.

DFS 를 이용하여 구현해 보자. `x` 의 값을 갖는 노드를 `v` 라고 하자.
`int up, int m_left, int m_right` 를 선언하여 `v` 의 선조들,
왼쪽 자손들, 오른쪽 자손들의 개수를 각각 저장하자.

`up > n/2 || m_left > n/2 || m_right > n/2` 이면
`P2` 가 반드시 이길 수 있다.

# Implementation

* [c++11](a.cpp)

# Complexity

```
O(N) O(1)
```
