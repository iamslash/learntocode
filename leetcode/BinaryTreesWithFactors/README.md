# Problem

[Binary Trees With Factors](https://leetcode.com/problems/binary-trees-with-factors/)

# Idea

수열 `A[]` 가 주어진다. `A[i]` 들을 이용해서 반드시 자식이 없거나 두
개인 binary tree 들을 만들어 보자. 단, 부모는 반드시 두 자식의 곱과
같아야 한다. 모든 경우의 수를 구하는 문제이다. 이때, 같은 `A[i]` 를
얼마든지 사용할 수 있다.

예를 들어 `A[] = (2, 4)` 를 살펴보자. `4` 가 부모가 되는 경우
`2, 2` 가 자식이 될 수 있다. 따라서 전체 경우는 `(2), (4), (4, 2, 2)`
가 되고 답은 3 이 된다.

이번에는 `A[] = (2, 4, 5, 10)` 을 살펴보자. `10` 이 부모가 되는 경우
`(2, 5), (5, 2)` 가 자식이 될 수 있다. 따라서 전체 경우는 `(2), (4),
(5), (10), (4, 2, 2), (10, 2, 5), (10, 5, 2)` 가 되고 답은 `7` 이다.

그러면 `A[] = (2, 4, 5, 10, 20)` 을 살펴보자. `20` 이 부모가 되는 경우
`(2, 5), (5, 2), (4, 5), (5, 4)` 가 자식이 될 수 있다. 그리고 `4` 는
다시 `(2, 2)` 가 자식이 될 수 있다.

예전에 구한 것을 이용하여 새로운 것을 구하는 방식이다. dynamic
programming 이라 할 만 하다. 

먼저 캐시 `unordered_map<int, int64_t> C` 를 선언한다.  그리고 `A[]`
를 인덱스 `i` 를 이용하여 처음부터 순회하며 다음을 반복한다.

* `A[i]` 하나로 binary tree 를 만들 수 있기 때문에 `C[A[i]] = 1` 를
  수행한다.
* 인덱스 `j` 를 이용하여 `j < i` 동안 다음을 반복한다.
> * `A[i]` 를 부모라고 가정하고 `A[j]` 로 나누었을 때 나누어 떨어지고
   `C.count(A[i]/A[j]) == 1` 이면 다음을 수행한다.

```cpp
    C[A[i]] = (C[A[i]] + C[A[j]] * C[A[i]/A[j]]) % 1000000007;
```
> * `A[i] == 10` 이고 `A[j] == 2` 일 때 `A[j] == 5` 인 경우를 포함하여
    계산할 필요는 없다. `A[j]` 는 `A[0..i)` 이기 때문에 `A[j] == 5` 역시
    순회의 대상이 된다.

모든 반복을 마치면 `C[]` 의 값들을 `rslt` 에 더한다. `rslt` 가 곧 답이다.

# Implementation

* [c++11](a.cpp)

# Complexity

```
O(N^2) O(N)
```
