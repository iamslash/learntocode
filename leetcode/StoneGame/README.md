# Problem

[StoneGame @ leetcode](https://leetcode.com/problems/stone-game/description/)

# Idea

돌덩이들의 그룹들이 놓여있다. Alex 와 Lee 는 교대로 처음 그룹 혹은
마지막 그룹을 선택하여 돌동이들의 그룹을 하나씩 가져간다. 가장 많은
돌을 가져간 사람이 승자이다.  Alex 가 먼저 게임을 시작한다면
돌덩이들의 배열에 따라 Alex 가 이기는지 검사해보자.

돌덩이 그룹들의 개수는 짝수이다. Alex 는 항상 먼저 고른다.  그렇다면
마지막은 Lee 가 고른다. 돌의 개수를 모두 더하면 홀수이다. 비기는
승부는 없다.

돌덩이개수의 그룹을 `P` 에 저장하고 `P` 의 길이를 `n` 이라고 하자.
남아있는 돌덩이 그룹의 시작 인덱스를 `i`, 종료 인덱스를 `j` 라고 하여
bottom-up style 로 `C[0][n-1]` 를 추적해 보자. 다음과 같이 캐시를
정의한다.

```
C[i][j]: P[i]..P[j] 만큼 돌덩이 그룹들이 남아있을 때
Alex 혹은 Lee 가 선택하여 얻은 돌덩이의 최대 개수

i: 남아 있는 돌덩이들 그룹의 첫번째 인덱스
j: 남아 있는 돌덩이들 그룹의 미자막 인덱스
```

예를 들어서 `C[0][5]` 를 살펴보자. 돌덩이들의 그룹은 모두 6 개이다.
그룹의 개수가 짝수이기 때문에 Alex 가 `0` 혹은 `5` 중 하나를 선택하여
얻을 수 있는 돌맹이의 최대 개수가 저장되어 있다.

이번에는 `C[5][5]` 를 살펴보자. 돌맹이들의 그룹은 1 개이다.  그룹의
개수가 홀수이기 때문에 Lee 가 선택한다. `P[5]` 가 저장됨은 당연하다.

다음과 같이 `C` 를 bottom-up style 로 채워간다. 

```
for (int j = 1; j < n; ++j)
  for (int i = 0; i < n-j; ++i)
    C[i][i+j] = max(P[i] - C[i+1][i+j], P[i+j] - C[i][i+j-1])
```

`C` 를 1차원으로 줄여서 Space Complexity 를 더욱 줄여보자. 다음과 같이
캐시를 정의한다.

```
C[i]: P[i] 가 남아 있는 돌멩이 그룹들 중 첫번째 돌멩이 그룹일 때
Alex 혹은 Lee 가 선택하여 얻을 수 있는 돌맹이의 최대 개수

i: 남아 있는 돌덩이 그룹의 인덱스
```

예를 들어서 `C[5]` 를 살펴보자. `P[5]` 부터 몇개인지는 모르겠지만 많은
돌맹이 그룹들이 존재할 수 있다는 것은 알 수 있다. 모든 경우에 대해서
Alex 혹은 Lee 가 `P[5]` 혹은 `P[?]` 를 선택하여 얻을 수 있는
최대의 돌의 개수를 `C[5]` 에 저장한다.

이번에는 `C[0]` 을 살펴보자. `P[0]` 부터 `P[?]` 까지 돌맹이 그룹들이
존재할 때 얻을 수 있는 최대의 돌의 개수가 저장되어 있다. 따라서 `C[0] > 0`
이면 Alex 가 이기는 것이다.

다음과 같이 캐시를 bottom-up style 로 채워간다. `i` 는 남은 돌맹이
그룹들 중 시작하는 그룹의 인덱스이고 `j` 는 돌맹이 그룹의 개수를
의미한다. 따라서 `P[i]` 는 남은 돌맹이 그룹들의 처음을 의미하고
`P[i+j]` 는 돌맹이 그룹들의 마지막을 의미한다. `C[i+1]` 은 `P[i]` 를
선택했으니 `P[i+1]` 을 시작으로 하는 돌맹이 그룹들의 모든 경우에 대한
최대값이다.

```cpp
    for (int j = 1; j < P.size(); ++j) {
      for (int i = 0; i < P.size() - j; ++i) {
        C[i] = max(P[i] - C[i+1], P[i+j] - C[i]);
      }
    }
```

# Implementation

[c++11](a.cpp)

# Time Complexity

```
O(N^2)
```

# Space Complexity

```
O(N)
```
