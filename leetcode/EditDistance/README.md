# Problem

* [Edit Distance @ leetcode](https://leetcode.com/problems/edit-distance/)

# Idea

두개의 문자열 `M` 과 `N` 이 주어졌을 때 `M` 에서 
`N` 으로 변신하는 최소 단계의 수를 구하는 문제이다.
단계마다 한개의 문자를 삽입 또는 삭제 또는 치환할 수 있다.

이 문제는 1965 년에 만들어진 [Levenshtein
distance](https://en.wikipedia.org/wiki/Levenshtein_distance) 을
이해하면 쉽게 풀 수 있다.

예를 들어 `horse` 와 `ros` 를 살펴보자. 다음과 같이
표를 만들고 값을 채워보자. 테이블의 값은 suboptimal 이다. 세로가 `word1` 을 의미하고 
가로가 `word2` 를 의미한다. 

```
    r o s
  0 1 2 3
h 1 1 2 3
o 2 2 1 2
r 3 2 2 2
s 4 3 3 2
e 5 4 4 3
```

`int C[6][4]` 를 선언하고 위의 표와 같이 top-down style 로
채워나간다. 

`C[0][0]` 은 빈문자에서 빈문자로 가는 방법의 최소 수이다.
당연히 0 이다. `C[0][1]` 은 빈문자에서 `r` 로 가는 방법의 최소 수이다.
한문자만 삽입하면 되기 때문에 1 이다. `C[1][0]` 은 `h` 에서 빈문자로
가는 방법의 최소 수이다. 한문자만 삭제하면 되기 때문에 1 이다.
`C[1][1]` 은 `h` 에서 `r` 로 가는 최소 수이다. 한 문자만 치환하면 되기
때문에 1 이다.

`C[2][2]` 는 `ho` 에서 `ro` 로 가는 방법의 최소 수이다.
마지막 문자가 서로 같기 때문에 `C[1][1]` 과 같다.

`C[1][2]` 은 `h` 에서 `ro` 로 가는 최소 방법의 수이다. 즉, 모든 셀에 최소 방법의 수가 저장되어 있기 때문에 suboptimal
이다. 가능한 모든 상황을 고려하자. 즉 삽입, 삭제, 수정을 수행한 경우를 각각 따져보고 가장 최소 단계를 `C[1][2]` 에 저장한다.

* `h` 에서 `r` 로 간다. 그 다음에 `o` 를 삽입한다. 즉 `C[1][2] = C[1][1] + 1`
* `h` 를 삭제하고 빈문자에서 `ro` 로 간다. 바꿔말하면 `C[1][2]` 는
  `C[0][2]` 에서 삭제 1 번 (`h 삭제`) 을 수행한 것과 같다. 즉 `C[1][2] = C[0][2] + 1` 
* `h` 가 만약 `o` 라고 한다면 `C[1][2]` 는 `C[0][1]` 과 같다. 바꿔
  말하면 `C[1][2]` 는 `C[0][1]` 에 교체 1 번 (`h->o`) 을 수행한 것과
  같다. 즉 `C[0][1] + 1`

앞서 언급한 것들을 기반으로 다음과 같이 중요한 규칙을 발견할 수 있다.

```
//  insert operation : C[i][j] = C[i][j-1]   + 1
//  delete operation : C[i][j] = C[i-1][j]   + 1
// replace operation : C[i][j] = C[i-1][j-1] + 1

C[i][j] = a[i-1] == b[j-1] ? 
               C[i-1][j-1] :
               min(C[i-1][j-1], min(C[i-1][j], C[i][j-1])) + 1; 
```

마지막으로 `C[6][4] = 3` 가 답이다.

`C` 를 일차원으로 줄이고 현재 순회하는 값의 바로 이전 열의 값만
저장한다면 공간복잡도를 줄일 수 있다. 표를 머리속에 그려놓고 구현하면
매우 쉽다.

# Implementation

* [c++11](a.cpp)

# Complexity

```
O(MN) O(N)
```
