# Problem

[Number of Subarrays with Bounded Maximum](https://leetcode.com/problems/number-of-subarrays-with-bounded-maximum/)

# Idea

수열 `A[]` 와 숫자 `L, R` 이 주어지면 가장 큰 값이 `L` 보다 크거나
같고 `R` 보다 작거나 같은 부분수열들의 개수를 구하는 문제이다.

다음은 `A = (2, 1, 4, 3)` 일 때 부분집합의 개수를 구하는 과정이다.
인덱스 `i` 가 증가할 때 마다 부분집합의 개수를 더해나가면 전체
부분집합의 개수를 구할 수 있다.

```
     i          i            i            i            i 
  A: 2 1 4 3    2 1 4 3    2 1 4 3    2 1 4 3    2 1 4 3
cnt: 0          1          1 2        1 2 4      1 2 4 8
                (2)        (1)        (4)        (3)             
                           (2, 1)     (2,4)(1,4) (2,3)(1,3)(4,3)
                                      (2,1,4)    (2,1,3)(2,4,3)(1,4,3)
                                                 (2,1,4,3)
```

한편 인덱스 `i` 가 증가할 때 마다 구한 부분집합의 개수에서 `L, R`
조건에 맞지 않는 것의 개수를 제거하고 그 결과를 더해나가면 답이 될
것이다.

예를 들어 `A = (2, 1, 4, 3), L = 2, R = 3` 을 살펴보자.  참고로 답은
`(2), (2, 1), (3)` 이다.

임의의 `i` 에 대한 `A[0..i]` 는 다음과 같이 3 가지 부분집합으로 나눌 수
있다.

0. 모든 값이 `L` 보다 작은 부분집합
1. 모든 값이 `R` 보다 작거나 같은 부분집합
2. 모든 값이 `R` 보다 큰 부분집합

이때 `1` 의 길이에서 `0` 의 길이를 제거하면 우리가 구하고자 하는
부분답이 된다.

다음은 앞서 언급한 예의 풀이과정이다. `j` 는 `0` 에 해당하고 `k` 는 `1`
에 해당한다. `cnt` 는 최종답이다.

```
L:2 R:3

     i          i            i            i            i
  A: 2 1 4 3    2 1 4 3    2 1 4 3    2 1 4 3    2 1 4 3
  j: 0          0          1          0          0
  k: 0          1          2          0          1
cnt: 0          1          2          2          3
```

# Implementation

* [c++11](a.cpp)

# Complexity

```
O(N) O(1)
```
