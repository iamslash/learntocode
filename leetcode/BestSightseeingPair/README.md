# Problem

[Best Sightseeing Pair](https://leetcode.com/problems/best-sightseeing-pair/)

# Idea

수열 `A[]` 가 주어진다. `i < j` 에 대하여 가장 큰 `A[i] + A[j] + i -
j` 값을 구하는 문제이다.

위의 수식을 잘 살펴 보면 `i, j` 를 정하고 `A[i] + A[j] - distance(i,
j)` 를 계산해서 최대값을 찾는 것과 같다. `int rslt` 를 선언하여
최대값을 저장하자.

예를 들어서 `A = 8 1 5 2 6` 을 살펴 보자. 이때 `A[j] = 5` 일 때 `A[i]
= 8` 혹은 `A[i] = 1` 일 수 있다. 따라서 각 경우에 대해서 `rslt` 는
`12` 혹은 `5` 이다. 그런데 `A = 8 7 5 2 6` 의 경우는 어떨까? 이번에도
`A[j] = 5` 일 때 `A[i] = 8` 혹은 `A[i] = 7` 일 때 `rslt` 를 계산해
보면 둘다 12 이다.

이것을 바탕으로 다음과 같은 알고리즘을 생각할 수 있다. 

인덱스 `j` 를 이용하여 `A[]` 를 `[1..n)` 동안 순회하며 다음을 반복한다. 인덱스
`i` 는 `0` 으로 초기화 한다.

* `rslt = max(rslt, A[i] + A[j] + i - j)` 를 수행한다.
* `A[j]` 가 `A[i]` 가 될만 하면 `i = j` 를 수행한다.
   
모든 반복을 마치면 `rslt` 가 곧 답이다.

그러나 조금 더 생각해 보면 `i` 를 저장하는 것 보다는 `A[i]` 를
저장하는 편이 더욱 효율적이다. 이것을 `ival` 에 저장하자.  또한 특정
`i` 에 대하여 `j` 가 늘어날 때 마다 `distance(i, j)` 는 하나씩
늘어난다. 따라서 `ival` 에 그 값을 반영하기 위해 `j` 가 증가할 때마다
`ival--` 를 수행하면 더욱 간결한 코드를 만들 수 있다.

# Implementation

* [c++11](a.cpp)

# Complexity

```
O(N) O(1)
```
