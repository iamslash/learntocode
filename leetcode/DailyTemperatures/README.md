# Problem

[Daily Temperatures](https://leetcode.com/problems/daily-temperatures/)

날짜별 온도의 모음 `T[]` 가 주어진다. 각 날짜별로 앞으로 따듯해 질려면
며칠이 남아 있는지를 저장한다.  앞으로 따듯해 지기위한 날짜의 모음을
구하라.

# stack

## Idea

예를 들어 `T = [73, 74, 75, 71, 69, 72, 76, 73]` 를 살펴보자.

`stack<int> stck` 를 선언하여 날짜의 인덱스를 저장한다. 인덱스에
해당하는 온도가 항상 내림차순이 되도록 유지한다. `vector<int> ans(n)`
를 선언하여 답을 저장한다.

```
                                        i                     
   T: 73 74 75 71 69 72 76 73       T: 73 74 75 71 69 72 76 73
stck:                            stck:  0                    
 ans:                             ans:                        
                                 
          i                                   i                     
   T: 73 74 75 71 69 72 76 73       T: 73 74 75 71 69 72 76 73
stck:  1                         stck:  2                      
 ans:  1                          ans:  1  1                     
                                 
                i                                   i                     
   T: 73 74 75 71 69 72 76 73       T: 73 74 75 71 69 72 76 73
stck:  2  3                      stck:  2  3  4            
 ans:  1  1                       ans:  1  1  

                      i                                   i                     
   T: 73 74 75 71 69 72 76 73       T: 73 74 75 71 69 72 76 73
stck:  2  5                      stck:  6           
 ans:  1  1     2  1              ans:  1  1  4  2  1  1 

                            i                                  i                     
   T: 73 74 75 71 69 72 76 73       T: 73 74 75 71 69 72 76 73
stck:  6                         stck:  6           
 ans:  1  1  4  2  1  1           ans:  1  1  4  2  1  1  
```

## Implementation

* [c++11](a.cpp)

## Complexity

```
O(N) O(N)
```

# two pointers

## Idea

두개의 인덱스 `i, j` 를 사용하여 `T[i]` 보다 큰 온도를 빨리 찾는
방법을 생각해 보자. `T[i] >= T[j]` 인 동안 `j` 를 멀리 보내는 방식으로
생각해 본다.

`vector<int> ans(n)` 를 선언하여 답을 저장한다.

인덱스 `int i` 를 선언하고 `[n-1,0]` 를 순회하며 다음을 반복한다.

* `int j = i + 1` 를 선언한다.
* `j < n && T[i] >= T[j]` 동안 다음을 반복한다.
  * `ans[j] > 0` 이면 `T[i]` 보다 큰 온도를 찾기 위해 `j` 를 멀리보낼
    수 있다. 즉, `j += ans[j]` 를 수행한다.
  * `ans[j] <= 0` 이면 `T[i]` 보다 큰 온도가 없다. 즉, `j = n` 를
    수행한다.
* `j < n` 이면 `ans[i] = j - i` 를 수행한다.

모든 반복을 마치면 `ans` 가 답이다.

다음은 `T = [73, 74, 75, 71, 69, 72, 76, 73]` 의 풀이과정이다.

```
                            i                     
   T: 73 74 75 71 69 72 76 73       T: 73 74 75 71 69 72 76 73
                            j
 ans:                             ans:                     

```

## Implementation

* [c++11](a.cpp)

## Complexity

```
O(N) O(N)
```
