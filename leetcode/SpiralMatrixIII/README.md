# Problem

[Spiral Matrix III @ leetcode](https://leetcode.com/problems/spiral-matrix-iii/description/)

# Idea

예를 들어 입력데이터가 `R=5, C=6, r0=1, c0=4` 라고 하면
다음과 같은 보드가 주어진다.

![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/24/example_2.png)

위 그림을 참고로 다음과 같이 탐색의 절차와 `(dy, dx)` 를 정리해보자.

* 오른쪽 1 이동후 우회전, (0, 1)
* 아래쪽 1 이동후 우회전, (1, 0)
* 왼쪽 2 이동후 우회전, (0, -2)
* 위쪽 2 이동후 우회전, (-2, 0)
* 오른쪽 3 이동후 우회전, (0, 3)
* 아래쪽 3 이동후 우회전, (3, 0)
* 왼쪽 4 이동후 우회전, (0, -4)
* 위쪽 4 이동후 우회전, (-4, 0)
* 오른쪽 5 이동후 우회전, (0, 5)
* 아래쪽 5 이동후 우회전, (5, 0)
* 왼쪽 6 이동후 우회전, (0, -6)
* 위쪽 6 이동후 우회전, (-6, 0)

그렇다면 어떻게 `1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6` 수열을 만들어 낼
수 있을까?  `i` 을 0 부터 시작하는 숫자라 하고 `Ai` 을 인덱스 `i` 의 숫자라
해보자. 그렇다면 `Ai = i/2 + 1` 이다.

이번에는 `dy, dx` 에 사용할 부호를 살펴보자. `Ai` 의 숫자가 바뀔 때 마다 부호가 바뀌고 있음을 알 수 있다.

앞서 언급한 것들을 종합하여 루프를 설계해 보자. 가장 바깥 루프는 모든 셀을 순회할 수 있어야 하고 인덱스를 `i` 라고 하자. 안쪽 루프는 `i` 에 대해 `Ai` 를 생성해야 한다. 안쪽 루프가 끝나면 부호를 전환해야 한다. 다음의 표현을 이용하자. `dt = dy; dy = dx; dx = -dt`

# Implementation

[c++11](a.cpp)

# Time Complexity

```
```

# Space Complexity

```
```
