# Problem

* [Distinct Subsequences](https://leetcode.com/problems/distinct-subsequences/)

# Idea

문자열 `S, T` 가 주어진다. `T` 가 `S` 의 부분문자열이
될 수 있는 방법은 몇가지인지 알아내는 문제이다.

`S="rabbbit, T="rabbit", s=S.size(), t=T.size()` 라고 하자.  다음과
같이 이차원의 표를 그리고 인덱스 `y, x` 를 증가시켜 순회한다. 
bottom-up style 로 값을 채워나간다. 이차원의 표를 저장할 자료구조를 
`int C[s+1][t+1]` 라고 정의했다면 `C[s][t]` 가 답이다.

```
//   0 r a b b i t   
// 0 1 0 0 0 0 0 0
// r 1 1 0 0 0 0 0            
// a 1 1 1 0 0 0 0
// b 1 1 1 1 0 0 0 
// b 1 1 1 2 1 0 0
// b 1 1 1 3 3 0 0
// i 1 1 1 3 3 3 0
// t 1 1 1 3 3 3 3
```

위의 표에서 중요한 부분 몇가지만 살펴본다.

* `C[*][0]`
  * `S` 의 길이가 아무리 많아도 `T` 는 빈문자열이므로 1 이다. 
* `C[0][1..]`
  * `T` 의 길이가 아무리 많아도 `S` 가 빈문자열이므로 0 이다.
* `C[1][1]`
  * `S[y] == T[x]` 이므로 1 이다.
* `C[1][2]`
  * `s < t` 이므로 0 이다.
* `C[4][3]`
  * 두가지 방법으로 만들 수 있는 경우의 수를 생각해보자. 첫째, `S[4] == T[3]` 이기 
    때문에 `C[4][3]` 은 `S[..4], T[..3]` 의 마지막 문자를 제거한 `S[..3], T[..2]` 으로
    구성할 수 있는 부분문자열의 개수와 같다. 즉 `C[3][2]` 와 같다. 
    둘째, `S` 가 하나 늘어나기 전의 경우의 수가 추가되야 한다. 따라서 `S[..3], T[..3]` 으로 구성할 
    수 있는 부분문자열의 개수를 구한다. 즉 `C[3][3]` 를 구한다. 두가지를 합하면
    `C[4][3]` 을 구할 수 있다.

언급한 몇가지를 기준으로 다음과 같이 중요한 규칙을 발견할 수 있다.

```cpp
C[y][x] = S[y] == T[x] ? C[y-1][x-1] + C[y-1][x] : C[y-1][x];
```

`C` 는 `C[t+1]` 와 같이 일차원으로 정의하면 공간복잡도를 줄일 수
있다. 단, `int prev` 를 하나 선언하여 이전 열의 정보를 저장해야 한다.

# Implementation

* [c++11](a.cpp)

# Complexity

```
O(ST) O(T)
```

