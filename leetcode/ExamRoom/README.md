# Problem

[Exam Room](https://leetcode.com/problems/exam-room/)

# Idea

학생들이 시험을 보기 위해 일렬로 앉는다고 해보자. 한명 씩 앉을 때 마다
서로의 거리가 최대이어야 한다. 만약 거리가 같은 자리가 있다면 인덱스가
가장 작은 번호의 자리를 취한다. 학생이 앉으면 자리를 리턴하는 함수
`seat` 과 학생이 떠나는 함수 `leave` 를 작성하는 문제이다.

학생이 앉을 때 자리 인덱스가 늘어나고 학생이 떠나면 자리 인덱스가
줄어드는 형태이다. 자리 인덱스가 항상 정렬되어 있으면 좋을 것 같다.
`set<int> m_sst` 를 선언하고 자리의 인덱스를 저장한다.

`m_sst` 를 처음부터 순회하여 간격이 가장 큰 곳을 찾는다.  이때 이전
자리 인덱스를 `int prev = -1` 에 저장하고 그때의 거리를 `int dist =
*m_sst.begin()` 에 저장한다.

간격이 가장 큰 곳을 찾으면 2 로 나누어 새로운 자리의 후보를 저장한다.
`m_sst` 는 오름차순으로 정렬되어 있기 때문에 가장 작은 인덱스의 자리를
취하게 된다.

만약 학생이 한명도 앉아 있지 않다면 `seat()` 는 `0` 을 리턴한다.  또한
`m_sst` 를 모두 순회 후에 마지막 학생과 방의 크기를 고려하여 자리
후보를 한번 더 따져 보아야 한다.

# Implementation

* [c++11](a.cpp)

# Complextiy

```
 seat: O(N) O(N)
leave: O(lgN) O(N)
```
