# Problem

* [Beautiful Arrangement II](https://leetcode.com/problems/beautiful-arrangement-ii/)

# Idea

`N` 이 주어지면 `[1..N]` 까지의 수열을 잘 배열하자.
인접한 수의 차이들이 서로 다른 `K` 개가 되야 한다.

예를들어 `N = 3, K = 1` 이라고 해보자.
수열 `1, 2, 3` 을 살펴보자. 인접한 수의 차이들은
`1` 밖에 없다. 따라서 답이된다.

다른예를 들어보자. `N = 3, 2` 이라고 해보자.
수열 `1 3 2` 를 살펴보자. 인접한 수의 차이들은
`1, 2` 와 같이 두가지 뿐이다. 따라서 답이된다.

일반적인 경우를 살펴보자. `N = 9, K = 8` 인 경우 
다음과 같은 모양의 수열을 생각할 수 있다.

```
   9   8   7   6   5
     1   2   3   4    
----------------------     
   9 1 8 2 7 3 6 4 5
d:  8 7 6 5 4 3 2 1
```

다음은 `N = 9, K = 5` 인 경우
다음과 같은 모양의 수열을 생각할 수 있다.

```
   1   2   3   5   7 
     9   8   4   6
----------------------     
   1 9 2 8 3 4 5 6 7
d:  8 7 6 5 1 1 1 1
```

다음은 `N = 9, K = 4` 인 경우
다음과 같은 모양의 수열을 생각할 수 있다.

```
   9   8         
     1   2 3 4 5 6 7
----------------------     
   9 1 8 2 3 4 5 6 7
d:  8 7 6 1 1 1 1 1
```


`K` 가 짝수 혹은 홀수 일때를 고려하여
`K` 만큼 교차 배열 하고 그 이후는 순서대로 배열하면 답이된다.

# Implementation

* [c++11](a.cpp)

# Complexity

```
```

