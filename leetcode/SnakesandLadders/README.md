# Problem

[Snakes and Ladders](https://leetcode.com/problems/snakes-and-ladders/)

# Idea

`NxN` 크기의 보드를 표현한 이차원 배열 `B[][]` 가 주어진다. 보드의
셀은 좌측아래를 `1` 로 시작하여 `N*N` 까지 지그재그 형태로 번호를
부여한다.  `1` 번 셀부터 시작하여 `N*N` 셀 까지 찾아가는데 필요한
최소의 수를 구하는 문제이다.  단, 특정 셀에서 주사위를 굴려 `[1..6]`
사이의 숫자만큼 전진할 수 있다.  그리고 `B[y][x] != -1` 이면 해당
번호의 셀로 점프한다.

전형적인 BFS 문제이다. 그러나 셀의 번호가 지그재그 형태로 부여되어
있으므로 일차원의 셀의 번호가 주어지면 이것을 이차원의 `y, x` 로
변환하는 것이 중요하다.

예를 들어 `3x3` 보드에 다음과 같이 셀의 번호가 부여되었다고 해보자.

```
7 8 9
4 5 6
1 2 3
```

* 일차원 셀 번호 `4` 를 변환해보자.
  * `y = (num - 1) / N = (4 - 1) / 3 = 1`
  * `x = (num - 1) % N = (4 - 1) % 3 = 0`
  * `y` 가 홀수이면 `x` 는 거꾸로 부여된다.
  * 따라서 `x = N - 1 - x = 3 - 1 - 0 = 2` 이다.
  * `y` 는 무조건 거꾸로 부여된다.
  * 따라서 `y = N - 1 - y = 3 - 1 - 1 = 1` 이다.
  
그리고 `unordered<int, int> step` 을 선언하여 `{셀의번호 : 단계수}` 를
저장한다. `queue<int> q` 를 선언하여 `셀의번호` 를 저장한다.  이제
`BFS` 를 수행할 수 있다.
 
# Implementation

* [c++11](a.cpp)

# Complexity

```
O(V+E) O(V)
```
