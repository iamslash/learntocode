# Problem

[Friends Of Appropriate Ages](https://leetcode.com/problems/friends-of-appropriate-ages/)

# Idea

나이의 배열 `A[]` 가 주어진다. 다음과 같은 경우를 제외하고 
`A[i]` 가 `A[j]` 에게 친구를 신청할 수 있다. 친구 신청의
개수를 구하는 문제이다.

```
A[j] <= 0.5 * A[i] + 7
A[j] > A[i]
A[j] > 100 && A[i] < 100
```

나이를 키로 개수를 값으로 하는 맵 `unordered_map<int, int> age2cnt` 를 선언하고 cartesian product 를 이용해서 해결하자.

예를 들어 `age2cnt = {17: 2, 18: 2}` 의 경우를 살펴보자.
`17 -> 18` 이 가능하지만 `18 -> 17` 은 불가능하다. `17 -> 18` 의 친구 신청의 개수는 `2 * 2 = 4` 이다.

또한 `17 -> 17, 18 -> 18` 이 가능하다. 각 경우의 친구 신청의 개수는 `2 * (2 - 1) = 2` 이다. 따라서 친구 신청의 전체 개수는 `4 + 2 + 2 = 8` 이다.

앞서 언급한 규칙들을 기반으로 `A[i] -> A[j]` 의 친구 신청 개수는 다음과 같이 계산한다.
먼저 `A[i]` 의 개수를 `a` 라 하고 `A[j]` 의 개수를 `b` 라고 해보자.
`a != b` 인 경우는 `a * b` 이다. 그러나 `a == b` 인 경우는 `a * (b - 1)` 이다.

세가지 조건을 고려하여 `A[i], A[j]` 범위를 제한하면 조금 더 
최적화 할 수 있다.

# Implementation

* [c++11](a.cpp)

# Complexity

```
O(N^2) O(N)
```