# Problem

[Decode Ways @ leetcode](https://leetcode.com/explore/interview/card/top-interview-questions-hard/121/dynamic-programming/861/)

숫자로 구성된 문자열 `s` 가 주어진다. `[1..26]` 은 `[A..Z] 로 디코딩할
수 있다. `s` 를 디코딩할 수 있는 경우의 수를 구하라.

# Idea

경우의 수를 구하는 문제이지만 이전 경우에 대해 하나를 더하는 식으로
문제를 풀수는 없다. 지금 살펴보는 문자가 디코딩 가능한 경우 과거에
구해놓은 경우의 수들을 더하는 방법이 필요하다.

`int n1 = 1, n2 = 0` 를 선언한다. `n1` 에 이전 문자 하나를 알파벳으로
디코딩했을 때 가능한 경우의 수를 저장한다. `n2` 에 이전 문자를 포함한
두개의 문자를 알파벳으로 디코딩했을 때 가능한 경우의 수를 저장한다.

`int m1, m2` 를 선언한다. `m1` 에 현재 문자 하나를 알파벳으로
디코딩했을 때 가능한 경우의 수를 저장한다. `m2` 에 현재 문자를 포함한
두개의 문자를 알파벳으로 디코딩했을 때 가능한 경우의 수를 저장한다.

`s[0]` 가 `0` 이면 디코딩할 수 없다. `0` 을 리턴하자.

인덱스 `i` 를 선언하여 `[1..n)` 동안 순회하면서 다음을 반복한다.

* `int m1 = 0, m2 = 0` 으로 초기화 한다.
* `char c = s[i]` 을 선언한다.
* `c >= '1' && c <= '9'` 이면 현재 문자 하나를 디코딩할 수
  있다. 디코딩 가능한 경우의 수는 현재 문자를 제외한 모든 경우의 수를
  더한 것과 같다. 즉, `m1 = n1 + n2` 를 수행한다.
* `int n` 을 선언하여 현재 문자를 포함한 두개의 문자를 숫자로
  저장한다. `n >= 10 && n <= 26` 이면 현재 문자를 포함한 두개의 문자를
  디코딩할 수 있다. 디코딩 가능한 경우의 수는 현재 문자를 제외하고
  이전문자 하나를 디코딩한 경우의 수와 같다. 즉, `m2 = n1` 를
  수행한다.
* 이제 다음 반복을 위해 `n1 = m1, n2 = m2` 를 수행한다.
  
모든 반복을 마치면 `n1 + n2` 가 답이다.

만약 `s = "7 0 2"` 의 경우 중간에 `m1 = 0, m2 = 0` 이 된다. 그리고
이후 `n1 = 0, n2 = 0` 이므로 답은 `0` 이 됨을 주의하자.

# Implementation

* [c++11](a.cpp)
* [java8](MainApp.java)
* [py3](a.py)
* [go](a.go)
* [js](a.js)
* [ruby](a.rb)

# Complexity

```
O(N) O(1)
```
