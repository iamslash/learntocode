# Problem

[Decode Ways @ leetcode](https://leetcode.com/explore/interview/card/top-interview-questions-hard/121/dynamic-programming/861/)

# Idea

경우의 수를 구하는 문제이지만 이전 경우에 대해 하나를 더하는 식으로
문제를 풀수는 없다. 지금 살펴보는 문자가 디코딩 가능한 경우 과거에
구해놓은 경우의 수들을 더하는 방법이 필요하다.

입력되는 문자열을 `s` 라고 하자. `s` 를 처음부터 끝까지 순회하는
인덱스를 `i` 라 하고 다음을 반복한다. 

`s[i]` 한 캐릭터를 디코딩할 수 있다고 판단했을 때 `s[i-1]` 에 해당하는
하나의 문자를 디코딩할 수 있는 경우의 수(`n1`)와 `s[i-2]s[i-1]` 에
해당하는 두개의 문자를 디코딩할 수 있는 경우의 수(`n2`)를 합하여
지금까지의 디코딩할 수 있는 모든 경우의 수를 구할 수 있다. 이것은
`s[i]` 한 문자를 디코딩할 수 있을 때 경우의 수이고 이것을 `m1` 에
저장한다.  그리고 `s[i-1]s[i]` 에 해당하는 두개의 문자를 디코딩 할 수
있다고 판단했을 때 `n1` 을 `m2` 에 저장한다. `n1 = m1`, `n2 = m2` 를
수행하고 `i` 를 하나 증가한다.

위의 반복을 수행한 후 `n1 + n2` 가 답이된다.

`s` 가 `0` 이면 `0` 을 리턴하자. 

`n1 = 1`, `n2 = 0` 으로 초기화 하여 `i` 는 `1` 부터 순회한다. `s` 가
`00` 이고 `i` 가 `1` 일 때 `m1 = 0`, `m2 = 0` 이므로 `n1 + n2` 는 `0`
이다.

# Implementation

[c++11](a.cpp)

# Time Complexity

```
O(N)
```

# Space Complexity

```
O(1)
```
