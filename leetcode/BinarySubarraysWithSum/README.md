# Problem

[Binary Subarrays With Sum](https://leetcode.com/problems/binary-subarrays-with-sum/)

# Idea

`0, 1` 로 구성된 수열 `A` 와 숫자 `S` 가 주어진다.
`A` 의 부분수열들중 합이 `S` 와 같은 것들은 몇개인지
구하는 문제이다.

예를 들어 `A = 1 0 1 0 1` 인 경우 인덱스 `i` 를 이용하여
순회하면서 부분 수열을 다음과 같이 만들어 보자.

* {1}
* {1, 0} {0}
* **{1, 0, 1}** {0, 1} {1}
* **{1, 0, 1, 0}** {0, 1, 0} {1, 0} {0}
* {1, 0, 1, 0, 1} **{0, 1, 0, 1}** **{1, 0, 1}** {0, 1} {1}

위의 과정을 참고하여 `A[i]` 의 부분수열은 다음과 같다.
바로 이전 단계 `A[i-1]` 에서 만들었던 부분 수열들에 `A[i]` 를
삽입하거나 마지막에 `A[i]` 만을 원소로 갖는 수열을 만들어 낼 수 있다.

부분수열의 합이 `S` 인 것들을 `ans` 에 더해나가면 마지막에 `ans` 가
답이 된다. 그러나 이와 같은 brute force 방법은 
Time Limit Exceeded 를 발생할 수 있다.

이번에는 prefix sum 을 이용해 보자.

맵 `unordered_map<int, int> ump = {{0, 1}}` 을 선언하고 
`{[A[0]..A[i]] 의 합 : [A[0]..A[i]] 의 합과 같은 부분수열의 개수}` 를 저장하자.
그리고 `int psum` 을 선언하고 `[A[0]..A[i]]` 의 합을 `psum` 에 저장한다.
그리고 인덱스 `i` 를 이용하여 순회할 때 마다 `ans += ump[psum - S]` 를
수행한다. 또한 `ump[psum]++` 를 수행한다. 모든 반복을 마치면 `ans` 가 답이다.

다음은 `A = 1 0 1 0 1, S = 2` 의 풀이과정이다.

```
   S: 2
                   i              i               i
   A: 1 0 1 0 1    1 0 1 0 1    1 0 1 0 1     1 0 1 0 1
psum: 0            1            1             2
 ans: 0            0            0             1
 ump: 0            0 1          0 1           0 1 2
      1            1 1          1 2           1 2 1

            i              i 
   A: 1 0 1 0 1    1 0 1 0 1 
psum: 2            3
 ans: 2            4
 ump: 0 1 2        0 1 2 3
      1 2 2        1 2 2 1
```

# Implementation

* [c++11](a.cpp)

# Complexity

```
O(N) O(N)
```