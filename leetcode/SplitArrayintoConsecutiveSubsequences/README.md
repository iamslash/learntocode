# Problem

[Split Array into Consecutive Subsequences](https://leetcode.com/problems/split-array-into-consecutive-subsequences/)

# Idea

수열 `V[]` 가 주어진다. 모든 숫자를 사용하여 3개 이상 연속된 수열들로 
만들 수 있는지 검증하는 문제이다.

숫자 `i` 에 대해서 발생횟수는 `freq[i]` 에 저장하고 `i` 로 끝나는 3개
이상의 연속된 수열의 개수는\ `tail[i]` 에 저장한다.  그리고 `V[]` 를
인덱스 `i` 를 이용하여 처음부터 끝까지 순회하면서 다음을 반복한다.

0. `freq[i] == 0` 이면 이전의 반복에 의해서 이미 처리되었다. 건너뛰자.
1. `tail[i-1] > 0` 이면 `i-1` 로 끝나는 3개 이상의 연속된 수열이
   있다는 의미이다. 그럼 `i` 를 추가하여 길이가 하나 늘어난 3 개
   이상의 연속된 수열을 만들 수 있다는 의미이다. 따라서 `tail[i-1]--,
   tail[i]++` 를 수행한다.
2. `freq[i+1] && freq[i+2]` 이면 `i` 로 끝나는 3 개 이상의 연속된
   수열은 없지만 `i` 부터 시작하는 3 개이상의 연속된 수열은 있다는
   의미이다. 따라서 `freq[i+1]--, freq[i+2]--, tail[i+2]++` 를
   수행한다.
3. `1, 2` 에 해당하지 않으면 `i` 를 이용하여 3 개 이상의 연속된 수열은
   만들 수 없다는 의미이다. false 를 리턴한다.
4. `1, 2, 3` 을 마치고 나면 `i` 는 3 개 이상의 연속된 수열에 속한다는
   의미이다. `freq[i]--` 하자.

모든 순회를 마치면 false 조건에 해당하지 않기 때문에 true 를 리턴한다.

이것을 더우 최적화 할 수 있다. 어떻게 동작하는 거지???

# Implementation

* [c++11](a.cpp)

# Complexity

```
O(N) O(1)
```
