# Problem

> [Maximum Vacation Days](https://leetcode.com/problems/maximum-vacation-days/)

비행노선 `F[][]` 와 도시체류기간 `D[][]` 가 주어진다. `F.length`
만큼의 도시들이 있다. `D[0].length` 주 만큼 출장을 가야한다.  일주일은
7 일로 구성되어 있다.

`F[u][v] == 1` 이면 `u` 도시에서 `v` 도시로 비행기를 타고 여행이
가능하다. `D[u][j]` 는 `u` 도시에서 `j` 번 째 주에 사용할 수 있는
휴가일 수 이다. `7 - D[u][j]` 일 동안은 일을 해야 한다.

`D[0].length` 주 만큼 출장을 갔을 때 최대로 사용할 수 있는 휴가일 수를
구하라. `u` 도시에서 출발하여 `j` 번째 주에 다시 `u` 도시에
머무를 수도 있다. 그렇다면 `D[u][j]` 만큼 다시 휴가를 사용할 수 있다.

# Idea

`F[u][v]` 는 `u` 도시에서 `v` 도시로 가는 비행노선이 있는지를
나타낸다.  `D[u][j]` 는 `u` 도시에서 `j` 번째 주에 사용할 수 있는
휴가일 수를 나타낸다. 한번 방문한 도시는 다시 방문할 수 있다.

예를 들어 `F[][], D[][]` 가 다음과 같은 경우를 살펴보자.

```
F = [
     [0,1,1],
     [1,0,1],
     [1,1,0]
    ]
D = [
     [1,3,1],
     [6,0,3],
     [3,3,3]
    ]
```

3 주 동안 도시들을 다니면서 최대 휴가일 수를 구해보자.  예를 들어 `0
-> 1` 로 이동하면 `6` 일의 휴가를 사용할 수 있다.  `1 -> 0` 로
이동하면 `3` 일의 휴가를 사용할 수 있다.  `2 -> 2` 로 이동하면 `3`
일의 휴가를 사용할 수 있다.  따라서 총 `12 = 6 + 3 + 3` 일의 휴가를
사용할 수 있다.

다음과 같이 부분문제를 정의하고 캐시를 사용해 memoization 한다.

```cpp
int dfs(F[][], D[][], C[][], city, week)
      F: 비행노선유무
      D: 도시휴가일자
C[u][j]: j 주차에 u 도시에서 출발할때 최대 휴가일자
   city: 출발도시
   week: 주차
```

# Implementation

* [c++11](a.cpp)
* [java8](MainApp.java)

# Complexity

```
O(N^2*K) O(NK)
```
