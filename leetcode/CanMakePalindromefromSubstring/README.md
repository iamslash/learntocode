# Problem

[Can Make Palindrome from Substring](https://leetcode.com/problems/can-make-palindrome-from-substring/)

# Idea

문자열 `s` 와 질의의 모음 `Q[]` 가 주어진다. `Q[i]` 를 순회하면서
`s[Q[i][0]]` 부터 `s[Q[i][1]]` 의 부분문자열의 문자들을 재배열하고
`Q[i][2]` 만큼 교체해서 palindrome 을 만들 수 있는지 검증하는
문제이다. 

예를 들어 `s = abcda, Q = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]]`
의 경우를 살펴보자.

* `Q[i] = [3, 3, 0]` 인 경우 부분문자열은 `d` 이고 재배열하고 `0` 개를 교체하여
  palindrome 이 가능하다.
* `Q[i] = [1, 2, 0]` 인 경우 부분문자열은 `bc` 이고 재배열하고 `0` 개를 교체하여
  palindrome 이 불가능하다.
* `Q[i] = [0, 3, 1]` 인 경우 부분문자열은 `abcd` 이고 재배열하고 `1` 개를 교체하여
  palindrome 이 불가능하다.
* `Q[i] = [0, 3, 2]` 인 경우 부분문자열은 `abcd` 이고 재배열하고 `2` 개를 교체하여
  palindrome 이 가능하다.
* `Q[i] = [0, 4, 1]` 인 경우 부분문자열은 `abcda` 이고 재배열하고 `1` 개를 교체하여
  palindrome 이 가능하다.
  
임의의 문자열 `S` 을 재배열하고서 몇개를 교체하면 palindrome 이
되는지를 파악해 보자. 단, 문자는 영문자 소문자이다. `int cnt` 를
선언하여 교체개수를 저장한다.

`vector<int> chr2cnt` 를 선언하여 `{character - 'a' : count of
character}` 를 저장하자. `Q[i][2]` 를 `k` 라고 하자.

`S` 를 순회하면서 `chr2cnt` 를 완성한다. `chr2cnt` 를 순회하면서
`chr2cnt[i]` 가 홀 수 이면 palindrome 을 만들기 위해 문자가 하나 더
필요하므로 `cnt++` 한다.

예를 들어 `S = "abc"` 인 경우를 살펴보자. `cnt = 3` 이다. 그러나 `cnt
/ 2 = 1` 으로도 palindrome 이 가능하다.

그러나 위와 같은 방법은 Time Limit Exceeded 를 발생시킨다. bitfield 를
이용하여 cnt 를 더욱 효율적으로 계산해 보자.

`int bm` 을 선언하여 bitfield 를 저장한다. `vector<int> ps(1)` 를
선언하고 부분합을 저장한다. 그리고 `s` 를 순회하면서 방문한 문자를 `c`
라고 할 때 다음을 반복한다.

* `ps.push_back(bm ^= 1 << (c - 'a'))`

이제 `ps` 가 완성되었다. `Q` 를 순회하면서 방문한 질의를 `q` 라 할 때
`ps[q[1]+1] ^ ps[q[0]]` 를 검사한다. 1 의 개수가 곧 `cnt` 이다.
`__builtin_popcount()` 를 이용하면 손쉽게 1 의 개수를 얻어낼 수 있다.
그리고 `q[2] >= cnt / 2` 이면 true 를 `ans` 에 저장한다.

예를 들어 `s = "abcda"` 인 경우 `ps` 를 살펴보자.

```
ps: 0: 00000000
    1: 00000001
    2: 00000011
    3: 00000111
    4: 00001111
    5: 00001110
```

* `q = [3, 3, 0]` 이라고 해보자. `ps[4] ^ ps[3] == 00001000` 이고 `cnt == 1`
이다. `q[3] == 0` 이고 `cnt / 2 == 0` 이므로 가능하다.
* `q = [1, 2, 0]` 이라고 해보자. `ps[3] ^ ps[1] == 00000110` 이고 `cnt == 2`
이다. `q[0] == 0` 이고 `cnt / 2 == 1` 이므로 불가능하다.
* `q = [0, 3, 1]` 이라고 해보자. `ps[4] ^ ps[0] == 00001111` 이고 `cnt == 4`
이다. `q[3] == 1` 이고 `cnt / 2 == 2` 이므로 불가능하다.
* `q = [0, 3, 2]` 이라고 해보자. `ps[4] ^ ps[0] == 00001111` 이고 `cnt == 4`
이다. `q[3] == 2` 이고 `cnt / 2 == 2` 이므로 가능하다.
* `q = [0, 4, 1]` 이라고 해보자. `ps[5] ^ ps[0] == 00001110` 이고 `cnt == 3`
이다. `q[3] == 1` 이고 `cnt / 2 == 1` 이므로 가능하다.

# Implementation

* [c++11](a.cpp)

# Complexity

```
O(N) O(N)
```
