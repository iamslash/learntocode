# Problem

[Jump Game II](https://leetcode.com/problems/jump-game-ii/)

# Idea

수열 `A[]` 가 주어진다. `A[0]` 에서 시작해서 최대 `A[i]` 만큼 jump 할
수 있다. `A[n-1]` 에 도착할 수 있는지 검증하는 문제이다.

사다리 바꿔타기와 같다.

예를 들어 `A = [2, 3, 1, 1, 4]` 의 경우를 살펴보자.

```
A: 2 3 1 1 4
    ----
      ------
        --
          --
```

`A[0] -> A[1] -> A[4]` 이기 때문에 답은 2 이다.

`int i, j, k` 를 선언한다. `k` 는 `i` 에서 가장 멀리 갈 수 있는 인덱스이다.
`j` 는 사다리를 바꿔탈 때의 인덱스이다.
인덱스 `i` 를 이용하여 `A` 를 처음부터 끝까지 순회하면서 다음을 반복한다.

* `k` 를 업데이트 한다. 즉, `k = max(k, i + A[i])` 를 수행한다.
* `i == j` 이면 `ans++` 하고 `j = k` 를 수행한다.

모든 반복을 마치면 `ans` 가 곧 답이다.

# Implementation

* [c++11](a.cpp)

# Complexity

```
O(N) O(1)
```
