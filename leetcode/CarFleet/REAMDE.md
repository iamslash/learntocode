# Problem

[Car Fleet](https://leetcode.com/problems/car-fleet/)

# Idea

자동차 위치의 모음 `P[]`, 속도의 모음 `S[]` 그리고 숫자 `tgt` 가
주어진다.  자동차가 달리다가 다른 자동차와 접촉하면 두 자동차는 하나의
군집을 이루며 둘 중 낮은 속도로 운행한다. 이후 다른 자동차와 접촉하면
역시 하나의 군집을 이루며 두 무리중 낮은 속도로 운행한다. 모든
자동차가 `tgt` 위치까지 운행할 때 만들어지는 군집의 개수를 구하는
문제이다.

예를 들어 `P[] = (10, 8, 0, 5, 3), S[] = (2, 4, 1, 1, 3), tgt = 12` 인
경우를 살펴보자. 아래와 같이 자동차의 인덱스, 속도, 목표지점까지
걸리는 시간을 표기해 보자. 목표지점까지 걸리는 시간은 `time = (tgt -
P[i])/S[i]` 와 같다.

```
       0    1    2    3    4    5    6    7    8    9   10   11   12
       |----|----|----|----|----|----|----|----|----|----|----|----|
    i: 2              4         3              1         0
speed: 1              3         1              4         2
 time: 12             3         7              1         1
```

이제 거리가 가장 먼 곳부터 가장 작은 곳 까지 순회하면서 `time` 을
비교해보자. `time[i] > time[i+1]` 일 때 새로운 군집이 만들어지는 것을
알 수 있다. 새로운 군집이 만들어질 때마다 `r` 을 하나씩 증가한다.
모든 반복이 끝나면 `r` 이 곧 답이다.

# Implementation

* [c++11](a.cpp)

# Complexity

```
O(PlgP) O(P)
```
