# Problem

[Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)

# Idea

주식의 일별 가격 `P[]`, 숫자 `K` 가 주어진다. 한번의 거래는 사고 팔고를 의미한다. 최대 `K` 번 거래할 수 있을 때 최고 이익을 구하는 문제이다.

예를 들어 `P = [3, 2, 6, 5, 0, 3], K = 2` 의 경우를 살펴보자. 다음과 같이 행은 `K` 열은 `P` 로  `C[][]` 을 제작한다. `C[y][x]` 는 `y` 번째 거래를 할 차례이고 주식가격은 `P[x]` 인 경우 최대이익을 의미한다. 

```
  3 2 6 5 0 3    
0 0 0 0 0 0 0
1 0
2 0
```

인덱스 `y` 를 `[0..K]` 동안 순회하며 다음을 반복한다.

* `int maxAfterBuy = -P[0]` 를 선언하고 마지막에 주식을 사고나서 최대이익을 저장한다.
* 인덱스 `x` 를 `[0..n-1]` 동안 순회하면 다음을 반복한다.
  * 주식가격이 `P[x]` 이다. 팔지 않았을 때와 팔았을 때 중 최대 이익을 저장한다. 즉, `C[y][x] = max(C[y][x-1], maxAfterBuy + P[x])`
  * 주식가격이 `P[x]` 이다. 현재 `maxAfterBuy` 와 `y-1` 번 거래후 `P[x]` 에 샀을 때 중 최대 이익을 `maxAfterBuy` 에 저장한다. 즉, `maxAfterBuy = max(maxAfter, C[y-1][x-1] - P[x])`

모든 반복을 마치면 `C[K][n-1]` 이 답이다.

다음은 `P = [3, 2, 6, 5, 0, 3], K = 2` 풀이 과정이다.

```
  3 2 6 5 0 3    3 2 6 5 0 3    3 2 6 5 0 3    3 2 6 5 0 3
0 0 0 0 0 0 0    0 0 0 0 0 0    0 0 0 0 0 0    0 0 0 0 0 0
1 0 0            0 0 4          0 0 4 4        0 0 4 4 4
2 0              0              0              0
B-3-2           -3-2-2         -3-2-2-2       -3-2-2-2 0

  3 2 6 5 0 3    3 2 6 5 0 3    3 2 6 5 0 3    3 2 6 5 0 3
0 0 0 0 0 0 0    0 0 0 0 0 0    0 0 0 0 0 0    0 0 0 0 0 0
1 0 0 4 4 4 4    0 0 4 4 4 4    0 0 4 4 4 4    0 4 4 4 4 4 
2 0              0 0            0 0 4          0 0 4 4 
B-3-2-2-2 0 0   -3-2           -3-2-2         -3-2-2-1

  3 2 6 5 0 3    3 2 6 5 0 3   
0 0 0 0 0 0 0    0 0 0 0 0 0   
1 0 0 4 4 4 4    0 0 4 4 4 4   
2 0 0 4 4 4      0 0 4 4 4 7           
B-3-2-2-1 4     -3-2-2-1 4 4   
```

답은 7 이다.

# Implementation

* [c++11](a.cpp)
* [java8](Solution.java)

# Complexity

```
O(N) O(1)
```
