# Problem

[Optimal Account Balancing](https://leetcode.com/problems/optimal-account-balancing/)

# Idea

`a` 가 `b` 에게 `c` 를 빌려주었다를 `(a, b, c)` 로 표현하고 이것을
트랜잭션이라고 하자. 트랜잭션의 모음 `T[]` 가 주어지면 모두 빛을
탕감하기 위해 필요한 최소 거래수를 구하는 문제이다.

예를 들어 트랜잭션의 모음이 `T[] = ((0, 1, 10), (2, 0, 5)` 와 같다면
다음과 같이 그래프로 표현가능하다. 

```
2 -> 0 -> 1
  5    10
```

`0` 은 `1` 에게 `10` 을 빌려주었으므로 `0` 의 빛은 `-10` 이고 `1` 의
빛은 `10` 이다.  `2` 는 `0` 에게 `5` 를 빌려주었으므로 `2` 의
빛은 `-5` 이고 `0` 의 빛은 `-5 = -10 + 5` 이다. 결과적으로 
`0, 1, 2` 의 빛은 `-5, 10, -5` 이다. 

즉 `0` 은 누군가로 부터 `5` 를 얻고 `1` 은 누군가에게 `10` 을 주고 `2`
는 누군가로 부터 `5` 를 얻으면 정산이 완료된다. 예를 들어 `1` 이
`0, 2` 에게 `5` 씩 주면 거래의 횟수는 2 가 되고 이것이 곧 답이다.

빛의 모음 `debts[]` 가 있다면 backtracking 으로 거래 횟수를 구할 수
있다. 거래의 횟수만 구하면 되기 때문에 유저의 아이디는 필요 없다.

다음과 같이 부분문제 `dfs` 를 정의하고 재귀적으로 해결한다.

```cpp
int dfs(vector<int> debts, int i)
 debts: 빛의 모음
     i: 이번 거래의 소스
return: 최소의 거래수
```

예를 들어 `debts[] = (5, -5, 5, -5)` 라고 해보자.

```
i            i            i       
5 -5 5 -5    5 -5 5 -5    5 -5 5 -5
   j              j               j

5  0 5 -5    5 -5 10-5    5 -5 5  0
1 + dfs(1)   1 + dfs(1)   1 + dfs(1)
```

다음은 recursion tree 이다.

![](recursiontree.png)

# Implementation

* [c++11](a.cpp)

# Complexity

```
O(N!) O(N)
```
