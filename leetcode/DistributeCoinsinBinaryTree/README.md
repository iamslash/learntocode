# Problem

[Distribute Coins in Binary Tree](https://leetcode.com/problems/distribute-coins-in-binary-tree/)

# Idea

트리의 루트노드 `root` 가 주어진다. 모든 노드가 정확히 1 개의 코인만
갖기 위해 코인의 이동횟수를 구하는 문제이다.

예를 들어 다음과 같은 다양한 경우에 대해 이동횟수를 살펴보자.

```
     2     3     3     1     1     1     1     2     1     0

     3     0     0     2     2     1     0     1     0     1
    / \   / \   / \   / \   / \   / \   / \   / \   / \   / \
   0   0 3   0 0   3 1   0 0   1 2   0 2   1 0   2 1   2 1   1
```

자식 에서 부모로 필요한 코인을 넘겨준다면 재귀적으로 해결할 수 있을 것
같다.  남는 코인은 양수로 필요한 코인은 음수로 넘겨주면 좋을 것 같다.

그렇다면 자식들이 필요로 하는 코인의 절대값을 이동횟수 `ans` 에 더하고
부모의 코인은 자신의 코인과 자식들이 필요로 하는 코인을 합하고 하나를
뺀 것으로 갱신한다. 위의 첫번째 예에서 왼쪽 자식의 코인이 0 일 때
하나를 빼야 필요로 하는 코인 `-1` 을 부모에게 리턴할 수 있다.

앞선 언급한 것 처럼 재귀적으로 해결하기 위해 다음과 같이 부분 문제
`dfs` 를 정의한다.

```
int dfs(TreeNode* u)

     u: 방문하는 노드
return: 서브트리 u 의 남는 코인 (양수) 혹은 필요한 코인 (음수)
```

그리고 다음과 같이 구현한다.

* `u == NULL` 이면 `0` 을 리턴한다. 
* 왼쪽 자식 노드가 리턴한 수를 `l`, 오른쪽 자식 노드가 리턴한 수를 `r`
  이라 하자. `abs(l) + abs(r)` 을 `ans` 에 더한다.  그리고 `u->val +
  l + r - 1` 을 리턴한다.

# Implementation

* [c++11](a.cpp)

# Complexity

```
O(V+E) O(1)
```
