# Problem

https://algospot.com/judge/problem/read/FENCE

# Idea

`N`개의 판자가 있다고 하자. 지금까지 구한 판자의 최대 넓이는
`maxarea`라고 하자. 판자의 높이들을 순차적으로 배열 `H`에
저장하자. `i`를 `0`번 판자부터 `N - 1`번 판자까지 순회하면서 특정
시점에 과거의 어떤 판자까지 넓이를 구해서 `maxarea`와 비교하고
필요하면 `maxarea`를 갱신한다. 그렇게 모두 반복 하게 되면 마지막
`maxarea`가 답이 된다. 반복의 종료를 위해 가상의 판자 높이 두개(-1,
0)를 `H`의 시작과 끝에 추가한다.

지금까지 순회한 판자들 중에 앞으로 언젠가 최대 넓이를 구할 수 있는
잠재능력을 갖는 판자의 인덱스를 `s` 스택에 저장하자. 즉 이번에 순회할
판자의 인덱스 `i` 보다 높이가 작거나 같은 판자의 인덱스를 스택에
저장하기 때문에 스택의 판자들은 높이의 오름차순으로 정렬되어 있다.

언급한 설명들을 근거로 해결방법을 다음과 같이 정리한다.

* 먼저 배열 `H`에 판자들의 높이를 입력 순서대로 저장하고 시작과 끝에
  가상의 판자 높이(-1, 0)를 저장한다.
* 스택 `s`에 `0`을 삽입한다. `0`번 판자의 높이는 -1이다.  인덱스 `r`을
  `0`부터 `N - 1`까지 순회하면서 다음을 반복한다.
  * 스택 `s`의 마지막 값이 `r` 판자 높이 보다 작거나 같을때 까지 다시
    다음을 반복한다.
    * 스택의 마지막 값을 꺼내서 `i`에 저장하자. 다시 스택의 마지막
      값을 가져와 `l`에 저장한다. 가지고 올 뿐 스택에서 꺼내지는
      않는다. `i` 판자가 `r-l-1`개 존재 하기 때문에 넓이는 `H[i] *
      (r-l-1)`이다.  이것을 `maxarea`와 비교하고 필요하면 갱신한다.
  * `r`을 스택에 삽입하자.
  
예를 들어서 판자들의 높이가 `1 8 2 2` 일때 `H`는 다음과 같다.

```
-1 1 8 2 2 0
```

`r`는 앞서 언급한 인덱스 `r`의 위치를 표기하고 `s`는 현재
스택에 삽입된 판자들을 표기한다. 마지막 `s`가 표기된 판자가
`s.top()` 판자를 의미한다.

```
       r
-1 1 8 2 2 0
 s s s
```

* `r`이 `3`일때 `s` 에 `0, 1, 2`가 저장되어 있을 것이다.  `3`번 판자의
  높이가 2이고 `s.top()` 판자의 높이는 8이므로 스택의 마지막 판자의
  높이가 `r` 판자의 높이보다 작거나 같을 때까지 스택에서 하나씩 판자를
  빼내어 넓이를 계산하고 `maxarea`와 비교 및 갱신한다.

```
         r
-1 1 8 2 2 0
 s s   s
```

* `r`이 `4`일때 스택에서 `2`는 사라졌다. `r`이 `3`일때 최대 넓이를 구하기
  위해 스택에서 빼냈기 때문이다.

```
           r
-1 1 8 2 2 0
 s s   s s
```

* `r`이 `5`일때 스택의 모든 판자들은 차례대로 빼내어 최대 넓이를
  계산하기 위해 사용될 것이다. `r`판자의 높이는 0이고 스택의 마지막
  판자의 높이는 `H[0]`을 제외하면 항상 `r`판자 보다 크기 때문이다.
  
* 모든 반복을 마치면 스택에는 가상 판자의 높이(-1, 0) 두개만 남게
  된다.

# Implementation

[c++11](a.cpp)

# Time Complexity

```
O(N)
```

입력데이터는 N개 이다. 판자의 데이터가 오름차순으로 정렬되어 있다고 해보자.
가장 최악의 상황이다. 1차 반복문과 2차 반복문 순회 횟수를 모두
합하여도 2N을 초과하지 않는다.
