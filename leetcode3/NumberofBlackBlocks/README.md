# Problem

[Number of Black Blocks](https://leetcode.com/problems/number-of-black-blocks/)

숫자 `h, w` 가 주어진다. 일차원 배열 `coords[]` 가 주어진다.  `h X w`
크기의 이차원 행렬이 있다고 하자. `coords[i]` 를 black block 이라고
하자.  `coords[i]` 를 중심으로 4 가지 사각형을 생각해 보자.

예를 들어 `coords[i] == (1,1)` 인 경우 다음과 같이 4 가지 사각형을
만들어 낼 수 있다. 모든 사각형은 black block 을 하나씩 포함한다.

```
0 0 0
0 1 0
0 0 0
```

`int[] ans = new int[5]` 를 완성하여 리턴하라. `ans[i]` 에서 `i` 는
black block 의 개수를 의미한다.

# Idea

예를 들어 `h = 3, w = 3, coords = [[0,0]]` 의 경우를 살펴보자.

```
1 0 0
0 0 0
0 0 0
```

따라서 답은 `[3, 1, 0, 0, 0]` 이다.

다음은 `h = 3, w = 3, coords = [[1,1]]` 의 경우를 살펴보자.

```
0 0 0
0 1 0
0 0 0
```

따라서 답은 `[0, 4, 0, 0, 0]` 이다.

`coords[i]` 를 중심으로 다음과 같이 사각형을 생각해 보자.  왼쪽 모서리
좌표를 key 로 만들어 caching 할 수 있다.

```
0 0 0
0 1 1
0 0 0

0,0: 0 + 0 * 3 = 0
0,1: 0 + 1 * 3 = 3
1,0: 1 + 0 * 3 = 1
1,1: 1 + 1 * 3 = 4

0,1: 0 + 1 * 3 = 3
1,1: 1 + 1 * 3 = 4
```

그러나 다음과 같이 오른쪽 모서리 좌표를 key 로 만들어 caching 해도
결과는 같다. 대신 구현이 깔끔해 진다.

`coords[i]` 를 중심으로 다음과 같이 사각형을 생각해 보자.  왼쪽 모서리
좌표를 key 로 만들어 caching 할 수 있다.

```
0 0 0
0 1 1
0 0 0

1,1: 1 + 1 * 3 = 4
1,2: 1 + 2 * 3 = 7
2,1: 2 + 1 * 3 = 5
2,2: 2 + 2 * 3 = 8

1,2: 1 + 2 * 3 = 7
2,2: 2 + 2 * 3 = 8
```

# Implementation

* [java11](MainApp.java)

# Complexity

```
O(HW) O(HW)
```
