# Problem

[Transform to Chessboard](https://leetcode.com/problems/transform-to-chessboard/)

`0, 1` 로 구성된 2D 배열 `B[][]` 가 주어진다.  두개의 행 혹은 두개의
열을 통째로 바꿀 수 있다.  인접한 `0` 혹은 `1` 이 없도록 교체할 수
있는 최소의 수를 구하라. 만약 조건을 만족할 수 없는 상태라면 `-1` 를
리턴하라.

# Idea

몇가지 규칙을 생각해 보자.

a. 첫 번재 행의 값을 기준으로 모든 행의 값은 첫번째 행의 값과 같거나
   혹은 반대이어야 한다. 예를 들어 첫 번째 행의 값이 `01010011` 이면
   다른 행의 값은 `01010011` 혹은 `10101100` 이어야 한다. 위 조건을
   만족하면 첫 번째 열을 기준으로 모든 열의 값은 첫 번째 열과 같거나
   반대이다. 따라서 열을 기준으로 다시 검증할 필요는 없다.
b. 임의의 행에 대해 `1` 의 개수는 `0` 의 개수와 같거나 최대 하나의
   차이만 있어야 한다. 조건 `a` 를 만족하면 첫 번째 행만 검증해도 된다.
   역시 임의의 열에 대해 `1` 의 개수는 `0` 의 개수와 같거나 최대 하나의 
   차이만 있어야 한다. 조건 `b` 를 만족하면 첫 번째 열만 검증해도 된다.

먼저 `B[][]` 가 인접한 `0` 혹은 `1` 이 없도록 교체할 수 있는지
점검한다.

예를 들어 다음과 같은 경우는 교체가 가능하다.

```
B: 0 1    1 0     
   1 0    0 1
```

그러나 다음과 같은 경우는 교체가 불가능하다.

```
B: 1 1    0 1    
   1 0    1 1   

B: 1 1    1 0  
   0 1    1 1 
```

임의의 `B[y][x]` 에 대해 `B[0][0] ^ B[y][0] ^ B[0][x] ^ B[y][x] == 1`
이면 `-1` 을 리턴한다.

그러나 다음과 같은 경우는 위의 조건을 만족하였음에도 불구하고 교체가
불가능한 경우이다.

```
B: 0 1    1 0    0 0    1 1
   0 1    1 0    1 1    0 0
```

# Implementation

* [c++11](a.cpp)

# Complexity

```
O(N^2) O(1)
```
