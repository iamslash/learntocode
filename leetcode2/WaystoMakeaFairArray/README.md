# Problem

[Ways to Make a Fair Array](https://leetcode.com/problems/ways-to-make-a-fair-array/)

수열 `nums` 가 주어진다. 임의의 수를 제거하고 홀수 인덱스의 합과 짝수
인덱스의 합이 같을 때를 균형을 이루었다고 해보자.  균형을 이루기 위해
제거해야할 숫자의 개수를 구하라.

# Idea

예를 들어 `nums = [2,1,6,4]` 의 경우를 살펴보자.

```
        i
nums: 2 1 6 4
```

`nums[i]` 를 기준으로 왼쪽 방향의 짝수 인덱스 숫자들의 합과 오른쪽
방향의 홀수 인덱스 숫자들의 합을 구한다. 비슷한 방법으로 왼쪽 방향의
홀수 인덱스 숫자들의 합과 오른쪽 방향의 짝수 인덱스 숫자들의 합을
구한다. 앞서 구한 두 종류의 합이 같다면 답을 하나 증가한다.

`int even, odd` 를 선언하여 `nums[i]` 를 기준으로 왼쪽 방향의 짝수
인덱스 숫자들의 합과 홀수 인덱스 숫자들의 합을 저장한다. `vector<int>
psEven(n+1), psOdd(n+1)` 를 선언하여 `nums[i]` 를 기준으로 오른쪽
방향의 부분합을 저장한다.

이제 인덱스 `i` 를 이용하여 `[0..n)` 를 순회하며 다음을 반복한다.

* `nums[i]` 를 제외하고 생각해 보자. 짝수 인덱스 숫자의 합은 `even +
  psOdd[i+1]` 이다. 홀수 인덱스 숫자의 합은 `odd + psEven[i+1]`
  이다. 두 합이 같으면 `ans` 를 하나 증가한다.
* `i % 2 == 0` 이면 `even += nums[i]` 를 수행한다.
* `i % 2 == 1` 이면 `odd += nums[i]` 를 수행한다.

모든 반복을 마치면 `ans` 가 곧 답이다.

# Implementation

* [c++11](a.cpp)

# Complexity

```
O(N) O(N)
```
