# Problem

[Contain Virus](https://leetcode.com/problems/contain-virus/)

이차원 배열 `G[][]` 가 주어진다. `G[y][x]` 는 `0, 1` 로 구성되어 있다.
`1` 은 바이러스에 감염된 지역이고 하루가 지나면 이웃한 곳이 감염된다.
감염된 지역이 최소가 되도록 벽을 설치해보자.  최소의 지역이 감염되기
위해 필요한 벽의 개수를 구하라.

# Idea

예를 들어 다음과 같은 경우를 살펴보자.

```
[[0,1,0,0,0,0,0,1],
 [0,1,0,0,0,0,0,1],
 [0,0,0,0,0,0,0,1],
 [0,0,0,0,0,0,0,0]]
```

다음과 같이 벽을 설치한다. 그리고 하루가 지난다.

```
[[0|1|0,0,0,0,1,1],
 [0|1|0,0,0,0,1,1],
    _
 [0,0,0,0,0,0,1,1],
 [0,0,0,0,0,0,0,1]]
```

다시 다음과 같이 벽을 설치한다. 그리고 감염은 멈춘다.

```
[[0|1|0,0,0,0|1,1],
 [0|1|0,0,0,0|1,1],
    _
 [0,0,0,0,0,0|1,1],
              _
 [0,0,0,0,0,0,0|1]]
```

따라서 답은 10 이다.

`int c = 2` 를 선언하여 감염 지역 component 를 찾을 때 마다 하나씩
증가한다. `unordered_set<int> candSet` 을 선언하여 특정 component
주변의 감염 후보 지역을 저장한다. `int maxCandidate` 를 선언하여 가장
많은 감염 후보 지역의 개수를 저장한다. `int maxWall` 을 선언하여 가장
많은 감염 후보 지역의 경우 설치할 벽의 개수를 저장한다. `int maxCell`
을 선언하여 가장 많은 감염 후보 지역의 경우 표식한 `c` 를 저장한다.

먼저 `G[][]` 를 순회하면서 하루가 지나면 가장 많이 감염시킬 수 있는
component 를 찾는다. 부분문제 `dfs(y,x)` 를 선언하여 재귀적으로
구현한다. `dfs(y,x)` 는 `candSet` 을 채우고 설치할 벽의 개수를
리턴한다. 그리고 `G[y][x] = c` 를 수행하여 component 에 표식을
남긴다. `maxCandiddate < candSet.size()` 이면 `maxCandidate, maxWall,
maxCell` 를 차례로 업데이트한다. 감염 지역 component 를 찾을 때 마다
`c` 를 하나 증가한다.

`maxCandidate == 0` 이면 반복을 종료하고 `ans` 를 리턴한다.

`maxCandidate != 0` 이면 최대 감염 지역을 찾은 것이다. `G[y][x] ==
maxCell` 이면 `G[y][x] = MAX_VAL` 를 수행하여 이미 해결된 것으로
표식을 남긴다. `G[y][x] != maxCell` 이면 `G[y][x] = 1` 를 수행하여
원래대로 돌려놓는다.

# Implementation

* [c++11](a.cpp)

# Complexity

```
```
