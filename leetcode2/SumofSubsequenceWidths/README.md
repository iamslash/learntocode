# Problem

[Sum of Subsequence Widths](https://leetcode.com/problems/sum-of-subsequence-widths/)

수열 `A` 가 주어진다. subsequence 의 최대 원소와 최소 원소의 차이를
width 라고 하자. 모든 subsequence 들의 width 의 합을 구하라.

# Idea

예를 들어 `A = [2, 1, 3]` 인 경우를 살펴보자.  `A` 를 오름차순으로
정렬해도 문제없다.

```
A: 1 2 3

subsequences & width:

   1        0
   2        0
   3        0
   1 2      1
   2 3      1
   1 3      2
   1 2 3    2
```

따라서 답은 `6` 이다.

`i < j` 인 두 인덱스 `i, j` 에 대하여 최소원소를 `A[i]` 라하고 최대
원소를 `A[j]` 라고 하자. 이것을 반드시 포함하는 subsequence 의 개수는
`2^(j-i-1)` 과 같다.

예를 들어 `[1,2,3]` 의 최소원소는 `A[0]` 이고 최대원소는 `A[2]` 이다.
이것을 포함한 subsequnce 는 `[1,3], [1,2,3]` 이다. `A[0], A[2]` 를
제외한 수 `A[1]` 로 만든 부분집합과 같다. `A[1]` 의 부분집합은 `{},
{2}` 이고 개수는 `2^n` 이므로 `2^1` 이다.

그리고 다음과 같은 규칙을 발견할 수 있다.

* if `j - i == 1`
  * `T_{1} = (A[2]-A[1])*2^{0} + (A[3]-A[2])*2^{0} + ...+(A[n]-A[n-1])*2^{0} = (A[n]-A[1])*2^{0}`
* if `j - i == 2`
  * `T_{2} = (A[3]-A[1])*2^{1} + (A[4]-A[2])*2^{1} + ...+(A[n]-A[n-2])*2^{1} = (A[n]+A[n-1]-A[2]-A[1])*2^{1}`
* if `j - i == 3`
  * `T_{3} = (A[4]-A[1])*2^{2} + (A[5]-A[2])*2^{2} + ...+(A[n]-A[n-3])*2^{2} = (A[n]+A[n-1]+A[n-2]-A[3]-A[2]-A[1])*2^{2}`
* if `j - i == k`
  * `T_{k} = (sum[n-k+1][n] - sum[1][k]) * 2^{k-1}`
  
따라서 답은 `T_{1} + T_{2} + ... + T_{k}`

# Implementation

* [c++11](a.cpp)

# Complexity

```
O(NlgN) O(1)
```
