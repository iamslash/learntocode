# Problem

[Russian Doll Envelopes](https://leetcode.com/problems/russian-doll-envelopes/)

# Idea

인형의 가로 세로의 길이의 쌍의 모임 `E[][]` 가 주어진다. 러시안 인형
처럼 포개었을 때 가장 많이 포개진 경우의 수를 구하라.

예를 들어 `E = [[5,4],[6,4],[6,7],[2,3]]` 의 경우를 살펴보자.  가로,
세로 순서대로 `E` 를 정렬한다. 캐시 `vector<int> C(E.size())` 를
선언하고 모두 `1` 로 채운다. `C[i]` 는 `i` 번째 인형이 자신을 포함하여
포갠 인형의 수를 의미한다.

인덱스 `i, j` 를 사용하여 이중으로 순회한다. 이때 `E[i]` 는 큰
인형이고 `E[j]` 는 작은 인형이다. `E[i]` 가 `E[j]` 를 포함할 수 있을
때 즉, `E[j][0] < E[i][1] && E[j][1] < E[i][1]` 일때 `C[i] = max(C[i],
C[j]+1)` 를 업데이트한다.

```
// E: [[5,4],[6,4],[6,7],[2,3]]
//                          i
// E: [[2,3],[5,4],[6,4],[6,7]]
//                    j
// C: 1 2 3 3
```

조금 더 최적화를 해보자. 만약 정렬방법을 다음과 같이 가로길이의 오름차순으로
하는데 만약 같은 가로 값이면 세로 값의 내림 차순으로 정렬해보자. 그리고 인덱스 
`i` 를 이용해서 `E` 를 처음부터 끝까지 순회하면서 다음을 반복한다.

* `E[i][0]` 보다 같거나 큰 값이 `C` 에 없다면 `C` 에 `E[i][0]` 을 삽입한다. 
* 그렇지 않다면 `C[i] = E[i][0]` 을 수행한다. 

```
// E: [[5,4],[6,4],[6,7],[2,3]]
//        i
// E: [[2,3],[5,4],[6,7],[6,4]]
// C: 
```

# Implementation

* [c++11](a.cpp)

# Complexity

```
O(NlgN) O(N)
```
