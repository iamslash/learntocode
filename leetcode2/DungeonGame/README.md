# Problem

[Dungeon Game](https://leetcode.com/problems/dungeon-game/)

2D 배열 `G[][]` 가 주어진다. 왕자가 `G[0][0]` 에서 출발하여
`G[h-1][w-1]` 까지 오른쪽 혹은 아래쪽으로 이동한다. `G[y][x]` 의 값이
음수이면 왕자의 HP 를 감소하고 양수이면 왕자의 HP 를 증가한다.  왕자의
HP 가 0 이면 바로 죽는다. 왕자가 공주에게 다가가기 위한 최소한의 HP 를
구하라.

# Idea

`int h, x` 를 선언하여 `G[][]` 의 높이와 넓이를 저장한다.

가장 단순한 경우부터 생각해 보자. 다음과 같이 `h = 1, w = 1`
인 경우를 살펴보자.

```
G: -1
```

`G[0][0]` 가 시작이자 종료지점이다. `HP` 가 1 이면 `G[0][0]` 에서 `1 +
(-1) = 0` 이 되어 실패다. 만약 `HP` 가 2 이면 `G[0][0]` 에서 `2 + (-1) = 1`
이 되어 성공이다.

이번에는 `G[0][0] = 0` 인 경우를 생각해 보자.

```
G: 0
```

역시 `G[0][0]` 가 시작이자 종료지점이다. `HP` 가 0 이면 `G[0][0]` 에서
`0 + 0 = 0` 이 되어 실패다. 만약 `HP` 가 1 이면 `G[0][0]` 에서 `1 + 0
= 1` 이 되어 성공이다.

이것을 바탕으로 다음과 같은 수식을 생각해 낼 수 있다.

```
HP + G[y][x] >= 1

          HP >= 1 - G[y][x]
```

그렇다면 위 수식에서 `1` 은 어떻게 수식으로 표현하는 것이 좋을까?
그것은 캐시 `C[h+1][w+1]` 를 선언하여 해결할 수 있다.

`C[h+1][w+1]` 를 선언하여 `(y, x)` 에서 `G[h-1][w-1]` 까지 여행하는데
필요한 최소한의 `HP` 를 저장해 놓자. 그렇다면 `C[0][0]` 가
답이된다. `C[][]` 는 기본값 `INT_MAX` 로 초기화 한다. `G[][]` 보다
추가된 열과 행은 경계값 `INT_MAX` 가 저장되어 loop invariant 를 수월히
구현하도록 한다.  `C[h-1][w] = 1, C[h][w-1] = 1` 로 초기화 하여 마지막
도착지에서 최소한으로 필요한 `1` 을 반영한다.

캐시 `C[][]` 를 앞에서 설명한 단순한 예에 다시 적용해 보자.  캐시는
`C[h-1][w-1]` 부터 시작하여 `C[0][0]` 으로 왼쪽 그리고 위쪽으로 채워
나간다. 왕자의 방향과는 반대이다.

```
G : -1

C : M 1
    1 M

C[0][0] = min(C[1][0], C[0][1]) - G[0][0]
        = 1 - (-1)
        = 2
```

이것을 정리하면 다음과 같은 수식을 만들어 낼 수 있다.

```
C[y][x] = min(C[y+1][x], C[y][x+1]) - G[y][x]
```

이때 `HP <= 0` 이면 무조건 `G[y][x]` 으로 오도록 유도해야 한다.  `HP =
1` 로 저장하자. 즉, `C[y][x] = 1` 이다. `HP > 0` 이면 `C[y][x]` 에
`HP` 를 저장한다.

```
G: -2  -3  3 
   -5 -10  1 
   10  30 -5 

C:  7   5  2 M
    6  11  5 M
    1   1  6 1
    M   M  1 M
```

인덱스 `i, j` 를 활용하여 `h-1, w-1` 부터 `0, 0` 까지 탐색하여
`C[y][x]` 를 채운다. 모든 반복을 마치면 `C[0][0]` 가 답이다.

# Implementation

* [c++11](a.cpp)
* [java8](Solution.java)
* [py3](a.py)
* [js](a.js)

# Complexity

```
O(HW) O(HW)
```
