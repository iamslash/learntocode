# Problem

[Palindrome Removal](https://leetcode.com/problems/palindrome-removal/)

수열 `A[]` 가 주어진다. `A[]` 가 모두 비워질 때까지 Palindromic
subarray subsequence 를 골라서 삭제한다. 이때 최소한의 삭제수를 구하는
문제이다.

# Idea

예를 들어 `A = [1, 2]` 인 경우 답은 2 이다.

```
A: 1 2
   1
     2
```

예를 들어 `A = [1 3 4 1 5]` 경우 답은 3 이다.

```
A: 1 3 4 1 5
   1 3   1
       4
           5
```

dynamic programming 으로 해결할 만하다.
캐시 `C[i][j]` 를 선언하고 `i` index 로 시작해서
`j` index 로 끝나는 문자열의 최소 삭제 횟수를 
저장한다.

```
길이 `len` 이 `1, 2` 일 때 `C` 를 채운다.

    1 3 4 1 5        1 3 4 1 5
    ---------        ---------
    0 1 2 3 4        0 1 2 3 4
1 0 1            1 0 1 2      
3 1   1          3 1   1 2     
4 2     1        4 2     1 2   
1 3       1      1 3       1 2
5 4         1    5 4         1

길이 `len` 이 `3` 일 때 `C` 를 채운다.
C[i][j] = C[i+1][j-1] + (A[i] == A[j] ? 0 : 2);

그리고 `i, j` 사이의 `k` 가 `[i,j)` 인 동안
`C[i][j]` 를 채운다.
C[i][j] = min(C[i][j], C[i][k] + C[k+1][j]);

    1 3 4 1 5        1 3 4 1 5
    ---------        ---------
    0 1 2 3 4        0 1 2 3 4
1 0 1 2 3        1 0 1 2 3    
3 1   1 2 3      3 1   1 2 3   
4 2     1 2 3    4 2     1 2 3 
1 3       1 2    1 3       1 2
5 4         1    5 4         1
```

모든 반복을 마치면 `C[0][4]` 가 답이다.
 
# Implementation

* [c++11](a.cpp)

# Complexity

```
O(N^2) O(N^2)
```
