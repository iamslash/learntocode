# Problem

[Pizza With 3n Slices](https://leetcode.com/problems/pizza-with-3n-slices/)

수열 `S[]` 가 주어진다. `S` 는 피자조각의 모음이다. 내가 하나 선택하면
왼쪽 오른쪽은 다른 사람이 선택한다. 따라서 한번에 3 개의 조각들이
없어진다. 내가 취한 피자 조각의 크기가 최대가 될 때 조각의 합을 구하는
문제이다.

# Idea

예를 들어 `S = [1, 2, 3, 4, 5, 6]` 인 경우를 살펴보자. 내가 `4, 6` 를
고르면 답은 `10` 이다.

`S` 의 길이를 `n` 이라고 하면 나는 `m = n/3` 만 큼 선택할 수 있다.
곧, 나는 `S[]` 에서 인접하지 않는 원소를 `m` 만큼 선택했을 때 최대합을
구하면 된다. 또한 `S[0]` 과 `S[n-1]` 은 서로 인접하기 때문에 `S[0]` 을
선택하면 `S[n-1]` 을 선택할 수는 없다. 따라서 `S[0..n-2]` 에서 `m`
만큼 선택했을 때 최대합과 `S[1..n-1]` 에서 `m` 만큼 선택했을 때
최대합을 비교하여 더 큰값을 얻으면 답이 된다.

`[1, 2, 3, 4, 5]` 의 경우를 생각해 보자.  인접하지 않은 `m` 개를
선택해야 한다. 현재 내가 선택한 경우와 선택하지 않은 두 경우를 비교하여
최대값을 저장한다. 

캐시 `C[n][m+1]` 을 선언하여 dynamic programming 으로 해결할 만 하다.

* `0` 개에서 선택하는 것은 의미가 없으므로 `C[0][*] = 0` 이다.  
* `*` 개에서 `0` 개 선택하는 것은 의미가 없으므로 `C[*][0] = 0` 이다.
* `1` 개에서 `*` 개 선택하는 것은 항상 첫번째 것을 선택할 수 밖에 없기
  때문에 `C[1][*] = 1` 이다.

```
C[i][j] = max(C[i-1][j], S[i-1] + C[i-2][j-1])
```

다음은 `S = [1, 2, 3, 4, 5, 6]` 의 풀이과정이다.

```
// S: 1 2 3 4 5 6
//
//
//     0 1 2
//   0 0 0 0
// 1 1 0 1 1
// 2 2 0 2 2
// 3 3 0 3 4
// 4 4 0 4 6
// 5 5 0 5 8

//     0 1 2
//   0 0 0 0
// 2 1 0 2 2
// 3 2 0 3 3
// 4 3 0 4 6
// 5 4 0 5 8
// 6 5 0 6 10
```

# Implementation

* [go](a.go)

# Complexity

```
O(N^2) o(N^2)
```
