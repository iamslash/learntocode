# Problem

[Decode Ways II](https://leetcode.com/problems/decode-ways-ii/)

문자열 `s` 가 주어진다. `s` 는 `[0..9]` 와 `*` 로 구성되어 있다.  `*`
는 `[1..9]` 와 같다. `[A..Z]` 는 `[1..26]` 과 대응된다.
`s` 를 디코딩하는 방법의 수를 구하라.

# Idea

예를 들어 `*` 의 경우를 살펴보자. 9 가지의 
경우가 가능하다.

```
1 2 3 4 5 6 7 8 9
A B C D E F G H I
```

`int cnt0 = 0` 를 선언하여 현재 자리수를 제외하고 마지막 2 자리를
고려하여 얻은 가짓수를 저장한다. `int cnt1 = 1` 를 선언하여 현재
자리수를 제외하고 마지막 1 자리를 고려하여 얻은 가짓수를
저장한다. `int cnt = 0` 을 선언하여 현재 자리수를 포함했을 때 얻은
가짓수를 저장한다.

`cnt0, cnt1` 가 잘 구해졌다면 현재 자리수 를 하나만 사용한 경우와 이전
자리수와 같이 두개를 사용한 경우를 각각 구할 수 있고 이것을 `cnt` 에
저장한다.

`cnt0 = cnt1, cnt1 = cnt` 를 수행한다.

# Implementation

* [c++11](a.cpp)

# Complexity

```
O(N) O(1)
```
