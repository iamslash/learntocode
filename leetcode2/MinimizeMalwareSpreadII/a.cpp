/* Copyright (C) 2020 by iamslash */

#include <cstdio>
#include <vector>
#include <queue>
#include <unordered_set>
#include <algorithm>

using namespace std;

// 420ms 32.82% 48.32MB 15.26%
// BFS
// O(N^I) O(N)
class Solution {
 private:
  int bfs(vector<vector<int>>& G, vector<int>& I, int u) {
    queue<int> q;
    unordered_set<int> visit = {u};
    int cnt = 0;
    for (int i : I) {
      if (i != u) {
        q.push(i);
      }
    }
    while (!q.empty()) {
      int f = q.front(); q.pop();
      if (visit.count(f))
        continue;
      visit.insert(f);
      cnt++;
      for (int v = 0; v < G.size(); v++) {
        if (v != f && G[f][v]) {
          q.push(v);
        }
      }
    }
    return cnt;
  }
 public:
  int minMalwareSpread(vector<vector<int>>& G, vector<int>& I) {
    int ans = 0;
    int n = I.size();
    int minCnt = G.size();
    sort(I.begin(), I.end());
    for (int u : I) {
      int cnt = bfs(G, I, u);
      if (cnt < minCnt) {
        minCnt = cnt;
        ans = u;
      }
    }
    return ans;
  }
};
