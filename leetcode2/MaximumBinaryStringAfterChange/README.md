# Problem

[Maximum Binary String After Change](https://leetcode.com/problems/maximum-binary-string-after-change/)

`0, 1` 로 구성된 문자열 `s` 가 주어진다. `00` 을 `10` 으로 `10` 을
`01` 로 얼마든지 수정할 수 있다.  두가지 동작을 적용하여 가장 큰
숫자의 문자열을 만들어 보자.  그 문자열을 구하라.

# Idea

예를 들어 다음과 같은 규칙을 발견할 수 있다.

```
   00    10
   10    01
  010   001   101
 0110  0101  0011  1011
01110 01101 01011 00111 10111
00000 10000 11000 11100 11110
```

`0` 은 왼쪽방향으로 계속 전진하여 또 다른 `0` 을 만나면 `10` 으로
바뀌는 것을 발견할 수 있다. 최종 숫자는 `0` 을 한개만 갖게 된다.

`int zeroCnt` 를 선언하여 `0` 을 만났을 때 횟수를 기록한다.  `int
oneCnt` 를 선언하여 첫번째 `0` 을 만나지 않은 상태에서 `1` 의 개수를
저장한다. 모두 `1` 로 바꾸고 `s[oneCnt + zeroCnt - 1]` 만 `0` 으로
바꾼다.

# Implementation

* [c++11](a.cpp)

# Complexity

```
```
