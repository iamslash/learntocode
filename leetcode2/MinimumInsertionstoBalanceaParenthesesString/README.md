# Problem

[Minimum Insertions to Balance a Parentheses String](https://leetcode.com/problems/minimum-insertions-to-balance-a-parentheses-string/)

왼쪽, 오른쪽 괄호로만 구성된 문자열 `s` 가 주어진다.  `(` 는 `))` 과
짝이 된다. 임의의 `(` 혹은 `)` 를 삽입하여 짝이 맞도록 하였을 때
필요한 괄호의 수를 구하라.

# Idea

`ans` 를 선언하여 필요한 괄호의 개수를 저장한다.  `right` 를 선언하여
필요한 오른쪽 괄호의 개수를 저장한다.  `ans` 는 한번 결정되면 절대
변하지 않는다. 그러나 `right` 은 늘어났다가 줄어들 수 있다.

이제 인덱스 `i` 를 이용하여 `s` 를 처음부터 끝까지 순회하면서 다음을
반복한다.

* `s[i] == '('` 이면 
  * `right` 이 홀수이면 `right--, ans++` 를 수행한다. 어차피 이후에
     `(` 와 짝이 맞아야할 오른쪽 괄호를 2 개 더할 것이다. 필요한
     오른쪽 괄호의 개수를 짝수로 맞추기 위해 `right` 을 하나 줄이고
     줄어든 만큼을 `ans` 에 더한다. 괄호는 무조건 하나 더 필요하기
     때문이다.
  * `right += 2` 를 수행한다. `(` 와 짝이 맞아야할 오른쪽 괄호는 2개가
    필요하기 때문이다.
* `s[i] == ')'` 이면
  * `right--` 를 수행한다. `)` 를 만났으므로 필요한 오른쪽 괄호의
    개수는 하나 줄인다.
  * `right < 0` 이면 `right += 2, ans++` 를 수행한다. 필요한 괄호의
    개수가 음수인 것은 오른쪽 괄호가 남는다는 의미이다. 양수로 만들기
    위해 `right += 2` 를 수행한다. 이때 짝이 맞기 위해 왼쪽 괄호가
    하나 더 필요하므로 `ans++` 를 수행한다.

모든 반복을 마치면 `ans + right` 가 곧 답이다.

```

//                i
//     s: ( ( ) ) )
// right: 2 4 3 2 1
//   ans: 0 0 0 0 0

//            i
//     s: ) ) ) ) ) ) )
// right: 1 0 1 
//   ans: 1 1 1

```

# Implementation

* [c++11](a.cpp)

# Complexity

```
```
